#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass book
\language american
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\paragraph_spacing double
\noindent
\align center

\shape italic
\size huge
\begin_inset ERT
status open

\begin_layout Standard


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\shape italic
\size huge
Physics with Home-made Equipment 
\end_layout

\begin_layout Standard
\paragraph_spacing double
\noindent
\align center

\shape italic
\size huge
and
\end_layout

\begin_layout Standard
\paragraph_spacing double
\noindent
\align center

\shape italic
\size huge
Innovative Experiments.
\shape default
\size giant

\begin_inset VSpace 1in
\end_inset


\end_layout

\begin_layout Standard
\align center

\size giant
PHOENIX
\end_layout

\begin_layout Standard
\begin_inset VSpace 1in
\end_inset


\end_layout

\begin_layout Standard
\align center

\shape italic
Ajith Kumar B P, VVV Satyanarayana, Kundan Singh & Parmanand Singh
\end_layout

\begin_layout Standard
\align center

\shape italic
Inter-University Accelerator Centre, New Delhi 110 067
\end_layout

\begin_layout Standard
\align center

\shape italic
Pramode C E, IC Software, Trissur, Kerala 
\end_layout

\begin_layout Standard
\begin_inset LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
Experiments are an important part of learning science and the capability
 to perform them with some confidence in the results opens up an entirely
 new method of learning.
 Experimental data can be compared with the results from mathematical models
 to examine the fundamental laws governing various phenomena.
 Research laboratories around the world performing science experiments use
 various types of sensors interfaced to computers for data acquisition.
 They formulate hypotheses, design and perform experiments, mathematically
 analyze the data to check whether they agree with the theory.
 Unfortunately the data acquisition hardware used is too expensive for school
 and college laboratories where teaching is the main goal and not research.
\end_layout

\begin_layout Standard
PHOENIX project is a modular, flexible and inexpensive system for experiment
 control, data acquisition and analysis utilizing the power of the personal
 computers and micro-controllers.
 Phoenix is developed at Inter-University Accelerator Centre, an autonomous
 research institute of University Grants Commission, India, providing particle
 accelerator based research facilities to the Universities.
 This document provides and overview of the equipment, its operation at
 various levels of sophistication and several experiments that can be done
 using it.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/rc_pc.png
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A Photograph of the Phoenix connected to USB port of a laptop PC showing
 RC integration of a square wave.
\begin_inset LatexCommand label
name "fig:A-Photograph-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
The Hardware
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/phm_block.eps
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
A schematic block diagram of Phoenix Hardware.
\begin_inset LatexCommand label
name "fig:A-schematic-block"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A photograph of Phoenix is shown in figure 
\begin_inset LatexCommand ref
reference "fig:A-Photograph-of"

\end_inset

.
 The connection to the PC can be made through the Serial/USB ports depending
 on the version of hardware used.
 The unit is powered by a 9V DC adapter but the USB version has a jumper
 option to run on the 5V supply of USB.
 The hardware schematic is shown in figure 
\begin_inset LatexCommand ref
reference "fig:A-schematic-block"

\end_inset

.
 The hardware features are listed below.
\end_layout

\begin_layout Itemize
10 bit resolution ADCs, 4 channels
\end_layout

\begin_layout Itemize
Digital Outputs, 4 channels
\end_layout

\begin_layout Itemize
Digital Inputs, 4 channels
\end_layout

\begin_layout Itemize
8 bit DAC, 1 channel
\end_layout

\begin_layout Itemize
Frequency Counter, up to 1 MHz
\end_layout

\begin_layout Itemize
Square wave Generator, up to 4 MHz
\end_layout

\begin_layout Itemize
1 mA Constant Current Source
\end_layout

\begin_layout Itemize
Variable gain Amplifiers
\end_layout

\begin_layout Itemize
5V regulated DC output
\end_layout

\begin_layout Itemize
Serial/USB interface to Computer
\end_layout

\begin_layout Standard
The analog inputs can digitize 0 to 5V range signals into a number ranging
 from 0 to 1023.
 The minimum conversion time is 10 microseconds.
 The voltage level changes at Digital Input/Output pins can be monitored/control
led with microsecond timing accuracy.
 Time intervals can be measured with micro-second resolution using the the
 Digital I/O sockets.
 The Analog output is implemented using a Pulse Width Modulated DAC having
 8 bit accuracy.
 The control and sensor elements used in the experimental setup are connected
 to the I/O channels.
 The plug-in feature allows expanding the hardware capabilities.
 Since most of the sensor elements give small output voltages, variable
 gain Amplifiers are provided to make them into the 0 to 5V range before
 feeding to the ADC inputs.
 A one milli Ampere constant current source and a 5V regulated DC output
 are also available.
 
\end_layout

\begin_layout Subsection
Accessories
\end_layout

\begin_layout Standard
Most of the experiments require some extra circuits connected to Phoenix.
 For example measuring the period of a pendulum uses a Light Barrier.
 The oscillating pendulum intercepts the light falling on a photo-transistor
 whose output is connected to one of the Digital Inputs for time interval
 measurement.
 Several such accessories with different levels of comnplexities have been
 developed and documented.
 Commercially available sensors for temperature, pressure, light etc.
 are used in making the accessories.
\end_layout

\begin_layout Section
The Software
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/phm_soft_block.eps
	width 7cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Schematic of the Software architecture of Phoenix.
\begin_inset LatexCommand label
name "fig: Software Schematic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The role of the software is to communicate to the control/sensor elements
 of the experiment as per the instructions from the user.
 To make program development easier, we have followed a layered approach
 as outlined in the figure 
\begin_inset LatexCommand ref
reference "fig: Software Schematic"

\end_inset

.
 The actual interaction with the hardware is done by the Firmware, written
 in C, running on the micro-controller, as per the commands from the PC
 through the serial link.
 The user programs communicate to the Python library to get the job done.
 Experimenter has the freedom to use the system at various levels of sophisticat
ion.
 
\end_layout

\begin_layout Subsection
Level 1: GUI Programs
\end_layout

\begin_layout Standard
Completed GUI programs are at the topmost level, where no programming is
 required.
 The user connects the sensors/control elements used in the experiment and
 collect the data using the GUI provided.
 Several such programs have been written for different experiments.
 GUI is useful for school level experiments where the teachers are not expected
 to do any programming.
 GUI programs are also written to make Phoenix to function as a low frequency
 storage oscilloscope, frequency counter, function generator etc.
\end_layout

\begin_layout Subsection
Level 2: Writing Programs using the Python Library
\end_layout

\begin_layout Standard
This is the level meant for those who want to develop new experiments using
 Phoenix.
 The hardware features can be accessed by calling the functions from the
 Python library, described in chapter 
\begin_inset LatexCommand ref
reference "cha:Python-Library-of"

\end_inset

.
 Python is amazingly simple to learn with its clean syntax and already has
 a huge collection of libraries for scientific computation and graphics.
 Python can be used either from inside the interpreter or by running the
 python programs stored in files.
 Phoenix can be accessed using single line commands, as illustrated below.
\end_layout

\begin_layout LyX-Code
import phm
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
v = p.read_block(200, 20, 1)
\end_layout

\begin_layout LyX-Code
p.plot(v)
\end_layout

\begin_layout Standard
This program samples the voltage signal connected to the ADC input 200 times,
 with a 20 microseconds interval between samples.
 The acquired data plotted and a screen-shot of the program output is shown
 in figure 
\begin_inset LatexCommand ref
reference "fig:Plot-of-Sinewave"

\end_inset

.
 Similarly there are functions for setting/reading the voltage level of
 Digital Input/Outputs and for measuring the time interval between level
 transitions on Digital Input Sockets.
 
\end_layout

\begin_layout Standard
Phoenix can be used with any computer or operating system having a Python
 Interpreter and a Python module to communicate to Serial/USB port.
 We recommend Free Software platforms like GNU/Linux since they come with
 non-restrictive licenses, better suited for academic work where sharing
 of knowledge is encouraged.
 Phoenix can also be used just by booting from the live CD which contains
 all the required software.
 You can also install it to your existing operating system.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/sin_wave.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Plot of a 1 KHz sine wave signal connected to Phoenix ADC input.
\begin_inset LatexCommand label
name "fig:Plot-of-Sinewave"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Level 3: Micro-controller programming and making Stand-alone systems
\end_layout

\begin_layout Standard
This level is of interest to engineering students who wish to develop micro-cont
roller based projects.
 Phoenix is designed around an AVR series micro-controller, ATmega16, from
 Atmel.
 It provides enough processing power and there is a free cross-compiler
 available.
 The Phoenix hardware functions as a micro-controller development system.
 One can write programs in C language, compile it using the cross-compiler
 of AVR, and upload the binary to ATmega16 chip through a cable connected
 to the parallel port of the PC.
 A LCD display is provided for easy program development.
 Several examples on how to convert Phoenix hardware into stand-alone devices
 like temperature monitor, frequency counter, rolling display etc.
 has been given in the documentation 
\begin_inset LatexCommand cite
key "book"

\end_inset

.
 
\end_layout

\begin_layout Section
Developing Science Experiments
\end_layout

\begin_layout Standard
Any science experiment involves control and measurement of physical parameters
 like temperature, pressure, voltage etc., as a function of time in most
 of the cases.
 The parameters to be measured need to be converted into electrical signals,
 which is done by appropriate sensor elements.
 The sensor outputs are processed and connected to the input sockets of
 Phoenix.
 Some experiments in electricity and electronics can be carried out without
 using any sensors since they directly generate electrical signals.
 The method can be illustrated better using the example given below.
 The details of more experiments are given in chapter 
\begin_inset LatexCommand ref
reference "cha:Experiments"

\end_inset

 and at www.iuac.res.in, the phoenix website.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/cap_expt.eps
	lyxscale 70
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Screen-shot of the program showing the voltage across a capacitor during
 charging and discharging through a resistor.
 The program shows a photograph of the connections to be made.
\begin_inset LatexCommand label
name "fig:Screenshot-RC discharge"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Charging and Discharging of a Capacitor
\end_layout

\begin_layout Standard
If a positive voltage step is applied to a capacitor through a resistor,
 the capacitor will start charging and the voltage across the capacitor
 will rise exponentially.
 This is taught in the theory classes but experimentally proving it require
 a fast digitizer and other electronics circuits.
 To do this using Phoenix, we connect a resistor from one of the Digital
 Outputs to an Analog input and the Capacitor from there to ground.
 Through software, we can change the voltage level at the Digital Output
 and then capture the resulting waveform across the capacitor by reading
 the ADC input channel CH0.
 Figure 
\begin_inset LatexCommand ref
reference "fig:Screenshot-RC discharge"

\end_inset

 shows a screenshot of the GUI program doing this experiment.
 All we have done to design this experiment is to combine the Digital Output
 and Analog Input features of Phoenix.
\end_layout

\begin_layout Section
Objectives and present status
\end_layout

\begin_layout Standard
The usage of computers for experiment control, data acquisition and analysis
 at the research level is well established.
 Several aspects needs to be considered while using the same for teaching
 science.
 Commercially available solutions does not allow the user to explore the
 internals of the system.
 What we have designed is a system that can be used at different levels
 depending on the programming and electronics expertise of the user.
 With this approach we hope to train teachers to use and later develop computer
 interfaced experiments based on their own ideas.
 Tight integration between data collection and analysis has been avoided.
 The stress is on getting the data into the computer with minimum amount
 of effort.
 The ability of the system to function as a micro-controller development
 may be useful for engineering students and student projects leading to
 equipment for physics experiments is an expected possibility.
 Phoenix can be used as a starting point for designing stand-alone systems
 like temperature controller, weather monitoring station, frequency counter
 etc.
\end_layout

\begin_layout Standard
The project started in 2005 by designing a parallel port based interface
 and several experiments using it.
 Feedback from the academic community has been instrumental in deciding
 the direction.
 The initial versions used C language for developing user programs but a
 Python option 
\begin_inset LatexCommand cite
key "pramode"

\end_inset

 was added later.
 The micro-controller version was done in 2006 to make the hardware more
 compact, expandable and less costly.
 The new version runs on any computer or operating system having Serial/USB
 ports and Python language support.
 Several universities have shown interest in using Phoenix and currently
 more than four hundred pieces are in circulation.
\end_layout

\begin_layout Standard
IUAC tries to make the system available to the maximum number of users.
 We conduct one day workshops at different places to demonstrate the system
 to physics teachers.
 Training programs are conducted at IUAC periodically for physics teachers
 from the universities.
 The hardware can be manufactured royalty free and we already have several
 vendors selling the hardware at a very low price.
 A live CD has been made to run the system without installing any software
 to the hard disk.
 A mailing list has been setup for user interaction.
 Complete details of the project are available on-line
\begin_inset LatexCommand cite
key "website"

\end_inset

.
 
\end_layout

\begin_layout Chapter
How it Works
\end_layout

\begin_layout Section
The hardware
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/phoenix_box.jpg
	lyxscale 70
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The top panel of Phoenix Interface.
 A coil is connected to one of the analog inputs through a level shifting
 amplifier.
\begin_inset LatexCommand label
name "fig:The-top-panel"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The most common Input/Output devices for a computer are Keyboard, Mouse,
 Monitor and Printer.
 However, you cannot feed a voltage signal to a computer for measuring its
 properties.
 Phoenix provides precisely this capability to your computer.
 It acts as a gateway to your computer through which Analog and Digital
 signals can travel.
 The analog signal are converted into digital form by Phoenix.
\end_layout

\begin_layout Standard
As you can see from figure 
\begin_inset LatexCommand ref
reference "fig:The-top-panel"

\end_inset

, the sockets on the top panel are grouped into different categories.
 You can connect external world signals to these sockets and Control/Monitor
 them using simple function calls written in Python Language.
 The major features are listed below
\end_layout

\begin_layout Itemize
Digital Inputs (Read the voltage level through software)
\end_layout

\begin_layout Itemize
Digital Outputs (Set the voltage level to 0 or 5V using software)
\end_layout

\begin_layout Itemize
Analog Inputs (Measure the value of an applied voltage)
\end_layout

\begin_layout Itemize
Analog Output (Generates a voltage under software control)
\end_layout

\begin_layout Itemize
Time interval measurements between voltage level changes
\end_layout

\begin_layout Itemize
Frequency counter
\end_layout

\begin_layout Itemize
Square wave generator
\end_layout

\begin_layout Itemize
Constant current source
\end_layout

\begin_layout Itemize
Amplifiers whose gain can be set using resistors
\end_layout

\begin_layout Standard
The functions of the various groups of top panel sockets are briefly explained
 below.
\end_layout

\begin_layout Enumerate
5V OUT - This is a regulated 5V power supply that can be used for powering
 external circuits.
 It can deliver only upto 100mA current , which is derived from the 9V unregulat
ed DC supply from the adapter.
\end_layout

\begin_layout Enumerate
Digital outputs - four RED sockets at the lower left corner .
 The socket marked D0
\begin_inset Formula $^{\text{*}}$
\end_inset

 is buffered with a transistor; it can be used to drive 5V relay coils.
 The logic HIGH output on D0 will be about 4.57V whereas on D1, D2, D3 it
 will be about 5.0V.
 D0 should not be used in applications involving precise timing of less
 than a few milli seconds.
\end_layout

\begin_layout Enumerate
Digital inputs - four GREEN sockets at the lower left corner.
 It might sometimes be necessary to connect analog outputs swinging between
 -5V to +5V to the digital inputs.
 In this case, you MUST use a 1K resistor in series between your analog
 output and the digital input pin.
\end_layout

\begin_layout Enumerate
ADC inputs - four GREEN sockets marked CH0 to CH3
\end_layout

\begin_layout Enumerate
PWG - Programmable Waveform Generator
\end_layout

\begin_layout Enumerate
DAC - 8 bit Digital to Analog Converter output
\end_layout

\begin_layout Enumerate
CMP - Analog Comparator negative input, the positive input is tied to the
 internal 1.23 V reference.
\end_layout

\begin_layout Enumerate
CNTR - Digital frequency counter (only for 0 to 5V pulses)
\end_layout

\begin_layout Enumerate
1 mA CCS - Constant Current Source, BLUE Socket, mainly for Resistance Temperatu
re Detectors, RTD.
\end_layout

\begin_layout Enumerate
Two variable gain inverting amplifiers, GREEN sockets marked IN and BLUE
 sockets marked OUT with YELLOW sockets in between to insert resistors.
 The amplifiers are built using TL084 Op-Amps and have a certain offset
 which has to be measured by grounding the input and accounted for when
 making precise measurements.
 
\end_layout

\begin_layout Enumerate
One variable gain non-inverting amplifier.
 This is located on the bottom right corner of the front panel.
 The gain can be programmed by connecting appropriate resistors from the
 Yellow socket to ground.
\end_layout

\begin_layout Enumerate
Two offset amplifiers to convert -5V to +5V signals to 0 to 5V signals.
 This is required since our ADC can only take 0 to 5V input range.
 For digitizing signals swinging between -5V to +5V we need to convert them
 first to 0 to 5V range.
 Input is GREEN and output is BLUE.
 
\end_layout

\begin_layout Standard
To reduce the chances of feeding signals to output sockets by mistake, the
 following Color Convention is followed.
\end_layout

\begin_layout Itemize
GREEN - Inputs, digital or analog
\end_layout

\begin_layout Itemize
RED - Digital Outputs and the 5V regulated DC output
\end_layout

\begin_layout Itemize
BLUE - Analog Outputs
\end_layout

\begin_layout Itemize
YELLOW - Gain selection resistors
\end_layout

\begin_layout Itemize
BLACK - Ground connections
\end_layout

\begin_layout Section
The Software
\end_layout

\begin_layout Standard
To access the Phoenix hardware, programs running on the PC should communicate
 to the micro-controller inside Phoenix.
 This is done over RS232 or USB interface, depending on the model used.
 The communication is handled by a Python library.
 User programs call simple functions to access various features of Phoenix.
 In order to use Phoenix, your computer must have the following software
 installed:
\end_layout

\begin_layout Enumerate
The Python interpreter.
\begin_inset Foot
status collapsed

\begin_layout Standard
Strictly speaking, any program having the ability to talk to the USB /Serial
 port can access Phoenix.
 A C library is also available on the CD but it is incomplete.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Pyserial module to access the RS232 port from Python.
\end_layout

\begin_layout Enumerate
PyUSB to access the USB ports.
\end_layout

\begin_layout Standard
If you are running from the Phoenix liveCD, all these things are available
 and ready to use.
 If you are running some other GNU/Linux distribution you need to install
 the Pyserial and PyUSB modules from the files provided on the Phoenix CD.
 You need to copy the Phoenix library 'phm.py' from the directory 'phoenix/softwa
re/interface' to the 'site-packages' directory inside the Python home directory
 
\begin_inset Foot
status collapsed

\begin_layout Standard
On most systems this will be /usr/lib/python2.x, where x is the version number
\end_layout

\end_inset

.
 All the software required to run Phoenix under MSWindows is located inside
 a directory named 
\begin_inset Formula $winPython$
\end_inset

 on the CD.
 Install all of them, by clicking on the icons.
 
\end_layout

\begin_layout Section
Communicating to Phoenix
\end_layout

\begin_layout Standard
You can use Python interpreter in two different ways.
 Start the Python interpreter and type the commands from it is one option.
 The '>>>' is the Python command prompt.
\end_layout

\begin_layout Standard
\align left
$ python
\end_layout

\begin_layout Standard
>>> import phm
\end_layout

\begin_layout Standard
>>> p = phm.phm()
\end_layout

\begin_layout Standard
Perhaps an easier option is to type your code into file using a Text Editor
 and invoke the interpreter with your program name as the first argument:
\end_layout

\begin_layout Standard
$ python mycode.py
\end_layout

\begin_layout Standard
Every Phoenix program should have the following two lines in the beginning
\end_layout

\begin_layout Standard
import phm
\end_layout

\begin_layout Standard
p = phm.phm()
\end_layout

\begin_layout Standard
The first line loads the Phoenix library called 'phm'.
 The second line invokes the function phm() from from the library, that
 returns an object of a class named 'phm'.
 All the functions to access Phoenix is inside this class.
 We call them by prefixing the object name, for example
\end_layout

\begin_layout LyX-Code
print p.read_inputs()
\end_layout

\begin_layout Standard
prints the status of the Digital Inputs.
\end_layout

\begin_layout Standard
The Python library to communicate to the hardware is explained in 
\begin_inset LatexCommand ref
reference "cha:Python-Library-of"

\end_inset

.
 You need them to develop new experiments.
 In the next chapter, we discuss some of the experiments that has already
 been developed and code is written.
\end_layout

\begin_layout Chapter
Experiments
\begin_inset LatexCommand label
name "cha:Experiments"

\end_inset


\end_layout

\begin_layout Standard
Several experiments on electricity and electronics can be done without much
 extra accessories.
 Science experiments require sensor elements that converts physical parameters
 into electrical signals.
 The number of science experiments one can do with Phoenix is limited mainly
 by the availability of sensor elements.
 Here we describe several experiments that can be done using some sensor
 elements that are easily available.
\end_layout

\begin_layout Standard
Almost all the experiments described below can be done using Python program
 named 
\shape italic
Experiments
\shape default
, having a Graphical User Interface.
 For better understanding of the internal working , one can also carry out
 them using the simple programs listed below.
 
\end_layout

\begin_layout Section
A sine wave for free - Power line pickup
\begin_inset LatexCommand label
name "sec:A-sine-wave"

\end_inset


\end_layout

\begin_layout Standard
There are two types of electric power available ,generally known as AC and
 DC power.
 The Direct Current or DC flows in the same direction and is generally made
 available from battery cells.
 The electricity coming to our houses is Alternating Current or AC, which
 changes the direction of flow continuously.
 What is the nature of this direction change.
 The frequency of AC power available in India is 50 Hz.
 Let us explore this using Phoenix-M and a piece of wire.
 A frequency of 50 Hz means the period of the wave is 20 milliseconds.
 If we capture the signal for 100 milliseconds there will be 5 cycles during
 that time interval.
 Let us digitize 200 samples at 500 microsecond intervals and analyze it.
\end_layout

\begin_layout Standard
Connect one and of a 25 cm wire to the Ch0 input of the ADC and let the
 other end float.
 The 50 Hz signals picked up by the ADC can be displayed as a function of
 time by the 
\emph on
read_block()
\emph default
 and 
\emph on
plot_data()
\emph default
 functions.
 With few lines of code you are making a simple CRO !
\end_layout

\begin_layout Standard
Type in the following program in a text editor 
\begin_inset Foot
status collapsed

\begin_layout Standard
if you are not familiar with standard GNU/Linux editors like vi or emacs,
 you can use `Nedit', which is available from the start menu of the Live-CD.
 Notepad under MSWindows
\end_layout

\end_inset

 and save it as a file named say `pickup.py'.
\end_layout

\begin_layout LyX-Code
import phm
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
while p.read_inputs() == 15:
\end_layout

\begin_layout LyX-Code
    v = p.read_block(200, 500,1)
\end_layout

\begin_layout LyX-Code
    p.plot_data(v)
\end_layout

\begin_layout LyX-Code
p.save_data(v, 'pickup.dat')
\end_layout

\begin_layout Standard
Run the program (by typing `python pickup.py' at the Operating System command
 prompt) after plugging one end of 25 cm wire to Ch0 of the ADC.
 Make sure that none of the digital input pins are grounded.
 You should see a waveform similar to that of figure 
\begin_inset LatexCommand ref
reference "fig:Power-line-Pickup"

\end_inset

.
 Adjust the position of the wire or touch the floating end with your hand
 to see the changes in the waveform.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/powerline-pickup.eps
	width 6cm

\end_inset

 
\begin_inset Graphics
	filename pics/pickup_xmgrace.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Power line Pickup 
\begin_inset LatexCommand label
name "fig:Power-line-Pickup"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
How do you terminate the program? The `while' loop is continuously reading
 from the digital inputs and checking whether the value is 15 - if none
 of the sockets D0 to D3 are grounded, the value returned by read_inputs()
 will definitely be 15 and the loop body will execute.
 If you ground one of the digital inputs, the value returned by read_inputs
 will be something other than 15; this will result in the loop terminating.
 Terminate the program when a good trace is on the screen, last sample collected
 is saved to the disk file 'pickup.dat' just before exiting.
\end_layout

\begin_layout Standard
You can do the same selecting 
\shape italic
Explore
\shape default
 from the menubar of Program 
\shape italic
Experiments
\shape default
.
 For capyuring the waveform and doing mathematical analysis, use the program
 named 'Analog Box'.
\end_layout

\begin_layout Subsection
Mathematical analysis of the data
\end_layout

\begin_layout Standard
By counting the number of waves within a given time interval one can roughly
 figure out the frequency of the line pickup but it won't be accurate and
 don't tell us much about the nature of the wave.
 Let us approach the problem in a more systematic manner.
 We have measured the value of the voltage at 200 different instances of
 time and want to find out the function that governs the time dependency
 of the voltage.
 Problems of this class are solved by fitting the experimental data with
 some mathematical formula provided by the theory governing the physical
 phenomena under investigation.
 Curve fitting is a method of comparing experimental results with a theoretical
 model.
 
\end_layout

\begin_layout Standard
Here the theoretical value of voltage as a function of time is given by
 a sinusoidal wave represented by the equation 
\begin_inset Formula $V$
\end_inset

= 
\begin_inset Formula $V_{\text{0}}$
\end_inset

 
\begin_inset Formula $\sin2\pi f$
\end_inset

 , where V
\begin_inset Formula $_{\text{0}}$
\end_inset

 is the amplitude and 
\begin_inset Formula $f$
\end_inset

 is the frequency.
 The experimental data can be 'fitted' using this equation to extract these
 parameters.
 We use the two dimensional plotting package 
\begin_inset Formula $xmgrace$
\end_inset

 for plotting a fitting the data.
 Xmgrace is free software and included on the CD along with user manual
 and a tutorial.
 Xmgrace is started from the command prompt with file 'pickup.dat' , saved
 by the python program, as the argument.
\end_layout

\begin_layout Quotation
# xmgrace pickup.dat
\end_layout

\begin_layout Standard
Select 
\begin_inset Formula $Data->Transformation->NonLinearCurveFitting$
\end_inset

 from the main menu and enter the equation 
\begin_inset Formula $V(t)$
\end_inset

= V
\begin_inset Formula $_{\text{0}}$
\end_inset

 
\begin_inset Formula $\sin(2\pi ft/1000000.0+\theta)+C$
\end_inset

 .
 Xmgrace accepts the adjustable parameters as A0, A1 etc.
\end_layout

\begin_layout Itemize
\begin_inset Formula $V(t)$
\end_inset

 is the value of voltage at time = 
\begin_inset Formula $t$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $V_{\text{0}}$
\end_inset

is the amplitude.
 The value will be close to 5000 milli volts (represented by parameter A0)
\end_layout

\begin_layout Itemize
\begin_inset Formula $f$
\end_inset

 is the frequency of the wave (parameter A1)
\end_layout

\begin_layout Itemize
\begin_inset Formula $t$
\end_inset

 is the value of time, divided by 1000000 to convert micro seconds to seconds
\end_layout

\begin_layout Itemize
\begin_inset Formula $\theta$
\end_inset

is the phase offset since we are not starting the digitization at zero crossing
 (parameter A2)
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

 is the amplitude offset that may be present (parameter A4)
\end_layout

\begin_layout Standard
Reasonable starting values should be given by the user for 
\begin_inset Formula $V_{\text{0}}$
\end_inset

 and 
\begin_inset Formula $f$
\end_inset

 to guide the fitting algorithm.
 Try different values until you get a good fit.
 The figure 
\begin_inset LatexCommand ref
reference "fig:Power line pickup and sine wave fit"

\end_inset

 shows the data plotted along with the fitted curve.
 The Curve fitting window 
\begin_inset LatexCommand ref
reference "fig:Curve-fitting-window"

\end_inset

 shows the parameter values.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/pickup_fit.eps
	lyxscale 70
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Curve fitting window of 
\begin_inset Formula $xmgrace$
\end_inset


\begin_inset LatexCommand label
name "fig:Curve-fitting-window"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The extracted value of frequency is 48.73 Hz ! Did not believe it and cross
 checked it by feeding a 50 Hz sine wave from a precision function generator
 to the ADC input.
 The result of a similar analysis gave 49.98 Hz.
 Checked with the power distribution people and confirmed that the line
 frequency was really below 49 Hz.
\end_layout

\begin_layout Standard
Exercise: Repeat the experiment by changing the length of the wire, touching
 one end by your hand and rising the other hand, moving it near any electrical
 equipment etc.
 (do not touch any power line).
 You can also analyze other wave forms if you have a signal generator.
\end_layout

\begin_layout Section
Capacitor charging and discharging
\begin_inset LatexCommand label
name "sub:Capacitor Discharge"

\end_inset


\end_layout

\begin_layout Standard
Every student learning about electricity knows that a capacitor charges
 and discharges exponentially but not very many has seen it doing so.
 Such experiments require fast data acquisition since the entire process
 is over within milli seconds.
 Let us explore this phenomena using Phoenix.
 All you need is a capacitor and a resistor.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/cap_circuit.eps
	width 6cm

\end_inset

 
\begin_inset Graphics
	filename pics/cap.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a)Circuit to study Capacitor.
 (b) The discharge curve.
\begin_inset LatexCommand label
name "fig:(a)Capacitor discharge"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Refer figure 
\begin_inset LatexCommand ref
reference "fig:(a)Capacitor discharge"

\end_inset

 for the experimental setup.
 The RC circuit under study is connected between the Digital output socket
 D3 and Ground.
 The voltage across the capacitor is monitored by the ADC channel 0.
 The voltage on D3 can be set to 0V or 5V under software control.
 Taking D3 to 5V will make the capacitor charge to 5V through the resistor
 R and then taking D3 to 0V will cause it to discharge.
 All we need to do is digitize the voltage across C just after changing
 the output of D3.
 Let us study the discharge process first.
 The python program 
\begin_inset Formula $cap.py$
\end_inset

 listed below does the job.
\end_layout

\begin_layout LyX-Code
import phm, time
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
p.write_outputs(8)
\end_layout

\begin_layout LyX-Code
time.sleep(1)
\end_layout

\begin_layout LyX-Code
p.enable_set_low(3)
\end_layout

\begin_layout LyX-Code
data = p.read_block(200,50, 0)
\end_layout

\begin_layout LyX-Code
p.plot_data(data)
\end_layout

\begin_layout LyX-Code
raw_input()         # wait for keypress
\end_layout

\begin_layout Standard
We make the digital output pins go high and sleep for 1 second (allowing
 the capacitor to charge to full 5V).
 The call to function 
\emph on
p.enable_set_low(3)
\emph default
 is similar to 
\emph on
select_adc()
\emph default
 or 
\emph on
add_channel()
\emph default
 ,whose effect is seen only later, when a read_block or multi_read_block
 is called.
 The idea is this - in certain situations, an ADC read should begin immediately
 after a few digital outputs are set to 1 or 0 - so we can combine the two
 together and ask the ADC read functions themselves to do the `set to LOW
 or HIGH' and then start reading.
  In this case, it brings to logic LOW pin D3, thereby starting the capacitor
 discharge process.
 The function then starts reading the voltage across the capacitor applied
 on ADC channel 0 at 250 microsecond intervals 
\begin_inset Foot
status collapsed

\begin_layout Standard
You may wonder as to why such a seemingly complicated function like enable_set_l
ow is required.
 We can as well make the digital output pin go high by calling write_outputs
 and then call read_block.
 The problem is that all these functions communicate with the Phoenix box
 using a slow-speed serial cable.
 For example, the read_block function simply sends a request (which is encoded
 as a number) over the serial line asking the micro-controller in the Phoenix
 box to digitize some input and send it back.
 By the time this request reaches the micro-controller over the serial line,
 the capacitor would have discharged to a certain extend! So we have to
 instruct the Phoenix micro-controller in just ONE command to set a pin
 LOW and then start the digitization process.
 For more details refer to secion 
\begin_inset LatexCommand ref
reference "sub:enable_set_high,-enable_set_low"

\end_inset


\end_layout

\end_inset

.
 The voltage across the capacitor as a function of time is shown in Figure
 
\begin_inset LatexCommand ref
reference "fig:(a)Capacitor discharge"

\end_inset

(b), which looks like an exponential function.
 When the rate of change of something is proportional to its instantaneous
 value the change is exponential.
 
\end_layout

\begin_layout Standard
Let us examine why it is exponential and what is an exponential function
 with the help of some elementary relationships.
 
\end_layout

\begin_layout Standard
The discharge of the capacitor results in a current I through the resistor
 and according to Ohm's law 
\begin_inset Formula $V=IR$
\end_inset

.
\end_layout

\begin_layout Standard
Voltage across the capacitor at any instant is proportional to the stored
 charge at that instant, 
\begin_inset Formula $V=Q/C$
\end_inset

.
 
\end_layout

\begin_layout Standard
These two relations imply 
\begin_inset Formula $I$
\end_inset

= 
\begin_inset Formula $\frac{Q}{RC}$
\end_inset

 and we current is nothing but the rate of flow of charge, 
\begin_inset Formula $I=\frac{dQ}{dt}$
\end_inset

.
\end_layout

\begin_layout Standard
Solving the differential equation 
\begin_inset Formula $\frac{dQ}{dt}$
\end_inset

= 
\begin_inset Formula $\frac{Q}{RC}$
\end_inset

 results in 
\begin_inset Formula $Q(t)=Q_{\text{0}}e^{-\frac{t}{RC}}$
\end_inset

 which also implies 
\begin_inset Formula $V(t)=V_{\text{0}}e^{-\frac{t}{RC}}$
\end_inset


\end_layout

\begin_layout Standard
Exercise: Modify the python program to watch the charging process.
 Change the code to make D3 LOW by calling p.write_outputs(0) and set it
 to HIGH just before digitization with p.enable_set_high(3).
 Extract the RC value by fitting the data using the equation using xmgrace
 package.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/glass_cap_setup.jpg
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Dielectric constant of glass from capacitance
\begin_inset LatexCommand label
name "fig:Dielectric-constant-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dielectric constant of materials can be calculated by fabricating capacitors
 and measuring the capacitance.
 The experimental setup used is shown in figure 
\begin_inset LatexCommand ref
reference "fig:Dielectric-constant-of"

\end_inset

.
\end_layout

\begin_layout Subsection
Linear Charging of a Capacitor
\end_layout

\begin_layout Standard
Exponential charging and discharging of capacitors are explained in the
 previous section.
 If we can keep the current flowing through the resistor constant, the capacitor
 will charge linearly.
 Let's wire up the circuit shown in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:caplinear"

\end_inset

 When D3 is HIGH no charging occurs.
 When D0 goes LOW the capacitor starts charging through the 1mA constant
 current source.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/caplinear-circuit.ps
	width 4cm

\end_inset

 
\begin_inset Graphics
	filename pics/caplinear-graph.eps
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) Circuit for Linear Charging of Capacitor.
 (b) The voltage waveform 
\begin_inset LatexCommand label
name "fig:caplinear"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
and run the following Python script:
\end_layout

\begin_layout LyX-Code
import phm, time
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
p.enable_set_low(3)
\end_layout

\begin_layout LyX-Code
p.write_outputs(8)
\end_layout

\begin_layout LyX-Code
time.sleep(1)
\end_layout

\begin_layout LyX-Code
v = p.read_block(400, 20, 0)
\end_layout

\begin_layout LyX-Code
p.plot_data(v)
\end_layout

\begin_layout LyX-Code
raw_input()  # wait for keypress
\end_layout

\begin_layout Standard
You will obtain a graph like the one shown in Figure 
\begin_inset LatexCommand ref
reference "fig:caplinear"

\end_inset

.
\end_layout

\begin_layout Section
IV Characteristics of Diodes
\end_layout

\begin_layout Standard
Diode IV characteristic can be obtained easily using the DAC and ADC features.
 The circuit for this is shown in figure 
\begin_inset LatexCommand ref
reference "fig:Circuit-for-Diode"

\end_inset

(a).
 Connect one end of a 1 KOhm resistor to the DAC output.
 The other end is connected to the ADC Ch0 Input.
 Positive terminal of the diode also is connected to the ADC Ch0 and negative
 to ground.
 The Voltage across the diode is directly measured by the ADC and the current
 is calculated using Ohm's law since the voltage at both ends of the 1 KOhm
 resistor is known.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../book2/pics/diode_circuit.eps
	width 4cm

\end_inset

 
\begin_inset Graphics
	filename pics/iv.eps
	width 8cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a)Circuit for Diode IV Characteristic.
 (b) VI curve of several diodes.
 
\begin_inset LatexCommand label
name "fig:Circuit-for-Diode"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have tried to study different diodes including Light Emitting Diodes
 with different wavelengths.
 The code 'iv.py' is ran for each diode and the output redirected to different
 files.
 For example; 'python iv.py > red.dat' after connecting the RED LED.
 The code 'iv.py' is listed below.
\end_layout

\begin_layout LyX-Code
import phm, time
\end_layout

\begin_layout LyX-Code
p=phm.phm()
\end_layout

\begin_layout LyX-Code
p.set_adc_size(2)
\end_layout

\begin_layout LyX-Code
p.set_adc_delay(200)
\end_layout

\begin_layout LyX-Code
va = 0.0
\end_layout

\begin_layout LyX-Code
while va <= 5000.0:
\end_layout

\begin_layout LyX-Code
   p.set_voltage(va)
\end_layout

\begin_layout LyX-Code
   time.sleep(0.001)
\end_layout

\begin_layout LyX-Code
   vb = p.zero_to_5000()[1]
\end_layout

\begin_layout LyX-Code
   va = va + 5000.0/255
\end_layout

\begin_layout LyX-Code
   print vb, ' ' , (va-vb)/1000.0
\end_layout

\begin_layout Standard
The program output is redirected to a file and plotted using the program
 'xmgrace', by specifying all the data files as command line arguments.
 The output is shown in the figure 
\begin_inset LatexCommand ref
reference "fig:Circuit-for-Diode"

\end_inset

(b).
 Note the difference between different diodes.
 If the frequency of the LEDs are known it is possible to estimate the value
 of Plank's constant from these results.
\end_layout

\begin_layout Section
Mathematical operations using RC circuits
\end_layout

\begin_layout Standard
RC circuits can be used for integration and differentiation of waveforms
 with respect to time.
 For example a square-wave of a particular frequency can be integrated to
 a triangular wave using proper RC values.
 In this experiment, we will apply a square wave (produced by the PWG) to
 CH0 of the Phoenix ADC.
 We will apply the same signal to an RC circuit (R=1K, C=1uF) and observe
 the waveform across the capacitor.
 The circuit is shown in figure 
\begin_inset LatexCommand ref
reference "fig:sqintegration-circuit"

\end_inset

(a) .We will repeat the experiment for 3 different cases by varying the Period
 of the square wave to show the different results.
\end_layout

\begin_layout Enumerate
RC 
\begin_inset Formula $\thickapprox$
\end_inset

T , Results in a Triangular wave form
\begin_inset LatexCommand ref
reference "fig:sqintegration"

\end_inset

(b)
\end_layout

\begin_layout Enumerate
RC >> T, The result is a DC level with some ripple 
\begin_inset LatexCommand ref
reference "fig:sqintegration"

\end_inset

(a)
\end_layout

\begin_layout Enumerate
RC << T, The sharp edges becomes exponential.
 
\begin_inset LatexCommand ref
reference "fig:sqintegration"

\end_inset

(b)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/sqintegration-circuit.ps
	width 5cm

\end_inset

 
\begin_inset Graphics
	filename pics/sqintegration-a.ps
	width 7cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) RC Integration circuit (b) Result with 1 KHz square wave
\begin_inset LatexCommand label
name "fig:sqintegration-circuit"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/sqintegration-b.ps
	width 6cm

\end_inset


\begin_inset Graphics
	filename pics/sqintegration-c.ps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) RC > T (b) RC < T
\begin_inset LatexCommand label
name "fig:sqintegration"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code 'sqintegrate.py' which generated these three plots is as follows:
\end_layout

\begin_layout LyX-Code
"""data was taken with 1K resistor, 1uF capacitor
\end_layout

\begin_layout LyX-Code
Three sets are taken:
\end_layout

\begin_layout LyX-Code
a) freq=1000 Hz and sampling delay = 10micro seconds, samples=400
\end_layout

\begin_layout LyX-Code
b) freq=5000 Hz and sampling delay = 10micro seconds, samples=300
\end_layout

\begin_layout LyX-Code
c) freq=100 Hz sampling delay = 20micro seconds, samples=300
\end_layout

\begin_layout LyX-Code
"""
\end_layout

\begin_layout LyX-Code
import phm
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
freq = 1000
\end_layout

\begin_layout LyX-Code
samples = 300
\end_layout

\begin_layout LyX-Code
delay = 10
\end_layout

\begin_layout LyX-Code
p.add_channel(0)
\end_layout

\begin_layout LyX-Code
p.add_channel(1)
\end_layout

\begin_layout LyX-Code
print p.set_frequency(freq)
\end_layout

\begin_layout LyX-Code
while p.read_inputs() == 15:
\end_layout

\begin_layout LyX-Code
   p.plot_data(p.multi_read_block(samples, delay, 0 )) 
\end_layout

\begin_layout Standard
Run the code by changing the frequency to study the relation between RC
 and T 
\end_layout

\begin_layout Section
Electric field produced by a changing magnetic field
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/induction.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Experiment to demonstrate electromagnetic induction.
 The wave form induced on a solenoid by moving a magnet through it is captured
 using Phoenix.
\begin_inset LatexCommand label
name "fig: Electromagnetic induction"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A voltage will be generated across a conductor kept in a changing magnetic
 field.
 We can create a change in the magnetic field by moving a permanent magnet
 near it.
 The magnitude of the voltage is decided by the length of the conductor
 and the rate of change of magnetic field.
 That means, to get larger voltage you can
\end_layout

\begin_layout Itemize
increase the length of the conductor
\end_layout

\begin_layout Itemize
use a stronger magnet
\end_layout

\begin_layout Itemize
move the magnet faster
\end_layout

\begin_layout Standard
In this experiment we will drop a small magnet into a coil having 5000 turns
 of insulated copper wire.
 The coil is connected between ground and the input of the level shifter,
 and the level shifter output to ADC input Ch0.
 We need the level shifter since the induced voltage can go to negative
 values depending upon the direction of motion.
 From the physics menu select Electromagnetic Induction.
 A screen as shown in figure will come up.
 Clicking on the 
\shape italic
Scan CH0
\shape default
 tag inside the text will tell the program to scan for the induced voltage,
 at regular intervals.
 Now drop the magnet into the coil.
 If the movement of the magnet through the coil coincides with the scanning,
 the waveform is captured and a message is displayed.
 You need to repeat dropping the magnet until this happens.
 If the waveform similar to the one shown in figure 
\begin_inset LatexCommand ref
reference "fig: Electromagnetic induction"

\end_inset

 is not obtained, click on 
\shape italic
Scan CH0
\shape default
 to repeat the process.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/magnet.eps
	width 5cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Magnetic field of a cylindrical magnet.
\begin_inset LatexCommand label
name "fig:Magnetic-field"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The induced voltage first builds up in one direction and then in the opposite
 direction.
 How do we explain this waveform.
 According to Faraday's law, the induced voltage across a coil with N turns
 is given by
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\varepsilon=-N\frac{d\Phi_{B}}{dt}\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $d\Phi_{B}/dt$
\end_inset

 is the rate of change of magnetic flux intercepted by the coil.
 From figure 
\begin_inset LatexCommand ref
reference "fig:Magnetic-field"

\end_inset

, it can be seen that the direction of the magnetic field is radially outwards
 near the north pole.
 Imagine the magnet entering the coil with the north pole first.
 The induced voltage goes up due to the effect of the outgoing flux from
 the north pole.
 Once the magnet enters inside the coil, one half of the coil will intercept
 a magnetic field in the outward direction and the other half a field in
 the inward direction.
 This results in a zero induced voltage when the magnet is in the middle
 of the coil.
 Once the magnet moves out of the coil through the opposite side the contributio
n from the south pole dominates and we find an induced voltage of opposite
 polarity.
\end_layout

\begin_layout Standard
Since the induced voltage is proportional to the rate of change of magnetic
 field, the amplitude of the waveform will increase with the velocity of
 the magnet.
 This can be verified by dropping the magnet from different heights.
\end_layout

\begin_layout Subsection
Mutual Induction 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/trans.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Mutual Induction between two coils
\begin_inset LatexCommand label
name "fig:Mutual-Induction-between"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the previous experiment, the changing magnetic field was generated by
 a moving magnet.
 We can create a varying magnetic field by changing the current flowing
 through a coil, by connecting it to an AC source.
 We can generate a sinusoidal voltage on the DAC socket.
 For that select 
\shape italic
Mutual Induction
\shape default
 from the 
\shape italic
physics
\shape default
 menu.
 The program will display a photograph of the connections to be made.
 The DAC socket is programmed to generate a 50 Hz sine wave ranging from
 0 to 5V.
 Passing it through a series capacitor will make amplitude ranging from
 -2.5 to +2.5V.
 This is given to the primary coil and also to the level shifter input for
 monitoring.
 The secondary coil is connected between ground and the input of the other
 level shifter.
 The level shifter outputs are connected to CH0 and CH1.
\end_layout

\begin_layout Standard
At this point you should see the sinusoidal primary waveform on the screen.
 The secondary waveform will be a horizontal line.
 Now bring the coils closer.
 Once you make the magnetic circuit using the ferrite core, the secondary
 output also will be displayed as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Mutual-Induction-between"

\end_inset

.
 Try reversing the mutual orientation of the coil to see its effect on the
 phase difference between primary and secondary waveforms.
\end_layout

\begin_layout Section
Generate Sound from Electrical Signals
\end_layout

\begin_layout Standard
In the previous experiments, we have seen that a magnet moving inside a
 coil induces a voltage across the coil.
 Moving the coil inside a magnetic field also does the same since only the
 relative motion matters.
 In a similar manner, 
\shape italic
if you allow a current to flow through a conductor kept inside a magnetic
 field the conductor will experience a force
\shape default
.
 This phenomenon is the basis of devices like electric motor, loudspeaker
 etc.
 We will take the case of the loudspeaker and explore the conversion of
 electrical energy into sound energy.
\end_layout

\begin_layout Standard
A loudspeaker has a movable coil placed inside a magnetic field and a paper
 cone connected to the coil.
 When a current is made to flow through the coil, it moves.
 By applying an AC voltage across the coil we can make the paper cone move
 back and forth to generate sound waves.
 We can change the frequency of the waveform to change the frequency of
 the sound generated.
\end_layout

\begin_layout Standard
To study this experimentally using Phoenix, connect a loudspeaker between
 PGW and Ground sockets along with a 100
\begin_inset Formula $\Omega$
\end_inset

 resistor to prevent overloading of the PWG output.
 Now click on the PWG socket and change the frequency, using the slider
 that pops up.
 You will observe that at some particular frequency, the intensity of sound
 shows a maximum.
 This is due to resonance.
 
\end_layout

\begin_layout Subsection
Creating music
\end_layout

\begin_layout Standard
The musical notes are produced by certain frequencies, for example a 261.63
 Hz frequency represents the note 'Sa'.
 One can produce some music by programming PWG to generate the notes in
 some order.
 From the help screen, clicking on the PWG Socket provides an option to
 play some tunes.
 
\end_layout

\begin_layout Section
Digitizing audio signals using a condenser microphone
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/mic-circuit.eps
	width 6cm

\end_inset

 
\begin_inset Graphics
	filename pics/buzzer_sound.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) Circuit to digitize the buzzer output sound using the microphone (b)
 The captured waveform.
\begin_inset LatexCommand label
name "fig:Buzzer and Mic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A condenser microphone is wired as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Buzzer and Mic"

\end_inset

(a) to capture the audio signals.
 One end of the microphone goes to Vcc through a resistor, the other end
 is grounded.
 The output is taken via a capacitor to block the DC used for biasing the
 microphone.
 The signal is amplified by a variable gain inverting amplifier.
 The amplified output is level shifted and connected to ADC channel 0.
 The program 'analog box' from the main menu can be used to capture the
 waveform and a screen-shot is shown in figure 
\begin_inset LatexCommand ref
reference "fig:Buzzer and Mic"

\end_inset

(b).
\end_layout

\begin_layout Standard
The frequency can be roughly estimated by looking through the data file
 for time interval between two zero crossings.
 For more accurate results, use the curve fitting option of the program.
\end_layout

\begin_layout Section
Synchronizing Digitization with External 'Events'
\end_layout

\begin_layout Standard
In the previous examples we have seen how to digitize a continuous waveform.
 We can start the digitization process at any time and get the results.
 This is not the case for transient signals.
 We have to synchronize the digitization process with the process that generates
 the signal.
 For example, the signal induced in a coil if you drop a magnet into it.
 Phoenix does this by making the 'read_block()' and 'multi_read_block()'
 calls to wait on a transition on the Digital Inputs or Analog Comparator
 Input.
 
\end_layout

\begin_layout Standard
Connect the condenser microphone as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Buzzer and Mic"

\end_inset

(a).
 Connect the output of the inverting amplifier to Digital Input D3 through
 a 1K resistor.
 The same is given to ADC through the level shifting amplifier.
 
\end_layout

\begin_layout Standard
Make some sound to the microphone.
 The 'p.enable_wait_high(3)' will make the read_block() function to wait
 until D3 goes HIGH.
 With no input signal the input to D0 will be near 0V, that is taken as
 LOW.
 The program 'wcro.py' used is listed below.
 
\end_layout

\begin_layout LyX-Code
import phm
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
p.enable_wait_high(3)
\end_layout

\begin_layout LyX-Code
while 1:
\end_layout

\begin_layout LyX-Code
   v = p.read_block(200,20,1)
\end_layout

\begin_layout LyX-Code
   if v != None:
\end_layout

\begin_layout LyX-Code
      p.plot_data(v)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/wait_read.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Collision sound.microphone
\begin_inset LatexCommand label
name "fig:Collision-sound.microphone"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exercise: Use a similar setup to study the voltage induced on a coil when
 a magnet is suddenly dropped into it.
\end_layout

\begin_layout Section
Temperature Measurements
\end_layout

\begin_layout Standard
In certain experiments it is necessary to measure temperature at regular
 time intervals.
 This can be done by connecting the output of a temperature sensor to one
 of the ADC inputs of Phoenix and record the value at regular intervals.
 There are several sensors available for measuring temperature, like thermocoupl
es, platinum resistance elements and solid state devices like AD590 and
 LM35.
 They work on different principles and require different kind of signal
 processing circuits to convert their output into the 0 to 5V range required
 by the ADC.
 We will examine some of the sensors in the following sections.
\end_layout

\begin_layout Subsection
Temperature of cooling water using PT100
\end_layout

\begin_layout Standard
PT100 is an easily available Resistance Temperature Detector , RTD, that
 can be used from -200
\begin_inset Formula $^{0}$
\end_inset

C to 800
\begin_inset Formula $^{\text{0}}$
\end_inset

C.
 It has a resistance of 100 Ohms at zero degree Celsius; the temperature
 vs resistance charts are available.
 The circuit for connecting PT100 with Phoenix is shown in figure 
\begin_inset LatexCommand ref
reference "fig:PT100-Circuit"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/pt100-circuit.eps
	width 6cm

\end_inset


\begin_inset Graphics
	filename pics/cooling_pt100.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) PT100 Circuit.
 (b) The cooling curve 
\begin_inset LatexCommand label
name "fig:PT100-Circuit"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The PT100 sensor is connected between the 1mA Constant Current Source and
 ground.
 The voltage across PT100 is given by Ohm's law, for example if the resistance
 is 100
\begin_inset Formula $\Omega$
\end_inset

 the voltage will be 100 * 1 mA = 100 mV.
 This must be amplified before giving to the ADC.
 The gain is chosen in such a way that that amplifier output is close to
 5V at the maximum temperature we are planning to measure.
 In the present experiment we just observe the cooling curve of hot water
 in a beaker.
 The maximum temperature is 100
\begin_inset Formula $^{\text{0}}$
\end_inset

C and the resistance of PT100 is 138
\begin_inset Formula $\Omega$
\end_inset

 at that point that gives 138 mV across it.
 We have chosen a gain of roughly 30 to amplify this voltage.
 The gain is provided by the non-inverting amplifier with a 330
\begin_inset Formula $\Omega$
\end_inset

 resistor from the Yellow socket to ground.
\end_layout

\begin_layout Standard
How do we calculate the temperature from the measured voltage ? The resistance
 is easily obtained by dividing the measured voltage by the gain of the
 amplifier.
 To get the temperature from the resistance one need the calibration chart
 of P100 or use the equation to calculate it.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\text{T}}$
\end_inset

= R
\begin_inset Formula $_{\text{0}}$
\end_inset


\begin_inset Formula $\left[1+AT+BT^{2}-100CT^{3}+CT^{4}\right]$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{T}$
\end_inset

 = Resistance at temperature T
\end_layout

\begin_layout Itemize
\begin_inset Formula $R_{\text{0}}$
\end_inset

is the resistance at 
\begin_inset Formula $0^{\text{0}}$
\end_inset

Celsius.
\end_layout

\begin_layout Itemize
\begin_inset Formula $A=3.908310^{\text{-3}}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $B=-5.77510^{\text{-7}}$
\end_inset


\end_layout

\begin_layout Standard
The first three terms are enough for temperatures above zero degree Celsius
 and the resulting quadratic equation can be solved for T.
 The program 'pt100.py' listed below prints the temperature at regular intervals.
 The output of the program is redirected to a file named 'cooling_pt100.dat'
 and plotted used xmgrace as shown in figure 
\begin_inset LatexCommand ref
reference "fig:PT100-Circuit"

\end_inset

.
\end_layout

\begin_layout LyX-Code
import phm, math, time
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
gain = 30.7       # amplifier gain
\end_layout

\begin_layout LyX-Code
offset = 0.0      # Amplifier offset, measured with input grounded
\end_layout

\begin_layout LyX-Code
ccs_current = 1.0 # CCS output 1 mA
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def r2t(r):       # Convert resistance to temperature for PT100
\end_layout

\begin_layout LyX-Code
   r0 = 100.0
\end_layout

\begin_layout LyX-Code
   A = 3.9083e-3
\end_layout

\begin_layout LyX-Code
   B = -5.7750e-7
\end_layout

\begin_layout LyX-Code
   c = 1 - r/r0
\end_layout

\begin_layout LyX-Code
   b4ac = math.sqrt( A*A - 4 * B * c)
\end_layout

\begin_layout LyX-Code
   t = (-A + b4ac) / (2.0 * B)
\end_layout

\begin_layout LyX-Code
   return t
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
def v2r(v):
\end_layout

\begin_layout LyX-Code
  v = (v + offset)/gain
\end_layout

\begin_layout LyX-Code
  return v / ccs_current
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
p.set_adc_size(2)
\end_layout

\begin_layout LyX-Code
p.set_adc_delay(200)
\end_layout

\begin_layout LyX-Code
strt = p.zero_to_5000()[0]
\end_layout

\begin_layout LyX-Code
for x in range(1000):
\end_layout

\begin_layout LyX-Code
   res = p.zero_to_5000()
\end_layout

\begin_layout LyX-Code
   r = v2r(res[1])
\end_layout

\begin_layout LyX-Code
   temp = r2t(r)
\end_layout

\begin_layout LyX-Code
   print '%5.2f %5.2f' %(res[0]-strt, temp)
\end_layout

\begin_layout LyX-Code
   time.sleep(1.0)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
Even though the experiment looks simple there are several errors that need
 to be eliminated.
 The CCS is marked as 1 mA but the resistors in the circuit implemented
 that can have upto 1% error.
 To find out the actual current do the following.
 Take a 100 Ohm resistor and measure its resistance 'R' with a good multimeter.
 Connect it from CCS to ground and measure the voltage 'V' across it.
 Now V/R gives you the actual current output from CCS.
 
\end_layout

\begin_layout Standard
For measurements around room temperature the voltage output is under a couple
 of hundred millivolts.
 For better precision this need to be amplified to 5V, to utilize the full
 range of the ADC.
 A gain of 20 to 30, depends on the upper limit of measurement, can be implement
ed using the variable gain amplifiers.
 The offset voltage of the amplifier should be measured by grounding the
 input and subtracted from the actual readings.
 The actual gain should also should be calculated by measuring the input
 and output at a a couple of voltages.
\end_layout

\begin_layout Standard
Another method of calibrating the setup is to measure the ADC output at
 0
\begin_inset Formula $^{\text{0}}$
\end_inset

and100
\begin_inset Formula $^{\text{0}}$
\end_inset

 and assume a linear relation, which may not be very accurate, between the
 ADC output and the temperature.
\end_layout

\begin_layout Section
Measuring Velocity of sound
\end_layout

\begin_layout Standard
The simplest way to measure the velocity of anything is to divide the distance
 travelled by time taken.
 Since phoenix can measure time intervals with microsecond accuracy we can
 apply the same method to measure the velocity of sound.
 We will first try to do this with a pair of piezo electric crystals and
 later by using a microphone.
\end_layout

\begin_layout Subsection
Piezo transceiver
\end_layout

\begin_layout Standard
A piezo electric crystal has mechanical and electrical axes.
 It deforms along the mechanical axis if a voltage is applied along the
 electrical axis.
 If a force is applied along the mechanical axis a voltage is generated
 along the electrical axis.
 We are using a commercially available piezo transmitter and receiver pair
 that has a resonant frequency of 40 KHz.
 The experimental setup is shown in figure 
\begin_inset LatexCommand ref
reference "fig:soundvel-piezo"

\end_inset

.
\end_layout

\begin_layout Standard
The transmitter piezo is excited by sending a 13 micro seconds wide pulse
 on Digital Output Socket D3 to generate a sound wave.
 The sound wave reaches the receiver piezo kept several centimeters away
 and induces a small voltage across it.
 This signal is amplified by two variable gain amplifiers in series, each
 with a gain of 100.
 The output is fed to Digital Input D3 through a 1K resistor
\begin_inset Foot
status collapsed

\begin_layout Standard
It is very important to use this resistor.
 The amplifier output is bipolar and goes negative values.
 Feeding negative voltage to D3 may damage the micro-controller.
 The 1KOhm resistor acts as a current limiter for the diode that protects
 the micro-controller from negative inputs.
\end_layout

\end_inset

.
 The interval between the output pulse and the rising edge of D3 is measured
 by the following program 'piezo.py'.
 The output is redirected to a file 
\end_layout

\begin_layout LyX-Code
import phm
\end_layout

\begin_layout LyX-Code
p=phm.phm()
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(13)
\end_layout

\begin_layout LyX-Code
p.set_pulse_polarity(0)
\end_layout

\begin_layout LyX-Code
p.write_outputs(0)
\end_layout

\begin_layout LyX-Code
for x in range(10):
\end_layout

\begin_layout LyX-Code
   print p.pulse2rtime(3,3)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/piezo-circuit.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Piezo Transceiver setup measuring velocity of sound
\begin_inset LatexCommand label
name "fig:soundvel-piezo"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Distance (cm)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Timeusec)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Dist.
 difference
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Time diff.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Vel.
 (m/s
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
224
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
253
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
344.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
282
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
58
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
344.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
310
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
86
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
348.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Velocity of sound
\begin_inset LatexCommand label
name "tab:Velocity-of-sound"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To avoid gross errors in this experiment one should be aware of the following.
 Applying one pulse to the transmitter piezo is like banging a metal plate
 to make sound, it generates a train of waves whose frequency is around
 40 KHz.
 The receiver output is a wave envelope whose amplitude rises quickly and
 then goes down rather slowly.
 When we amplify this signal one of the crests during the building up of
 the envelope makes the Digital Input HIGH.
 When we increase the distance between the crystals the amplitude of the
 signal also goes down.
 At some point this will result in sudden jump of 25 microseconds in the
 time measurement which is caused by D3 going HIGH by the next pulse.
 This can be avoided by taking groups of reading at different distances
 varying it by 3 to 4 centi meters.
\end_layout

\begin_layout Subsection
Condenser microphone
\end_layout

\begin_layout Standard
Velocity of sound can be measured by banging two metal plates together and
 recording the time of arrival of sound at a microphone kept at a distance.
 One metallic plate is connected to ground, another one is connected to
 a digital input say D0.
 The generated sound travels through air and reaches the microphone and
 induces an electrical signal.
 The electrical signal is amplified 200 times by two amplifiers in series
 and connected to D3.
 The experimental setup is shown figure 
\begin_inset LatexCommand ref
reference "fig:Velocity-of-sound"

\end_inset

.
 We have used 1 mm thick aluminium plates to generate the sound.
 When we strike one by the other, the digital input D0 gets grounded resulting
 in a falling edge at D0.
 The amplified sound signal causes a rising edge on D1 
\begin_inset Foot
status collapsed

\begin_layout Standard
Rising or falling edge depends on the amplifier offset etc.
 If the amplifier output will start oscillating when the sound signal arrives.
 If is already HIGH it will go LOW when the sound signal arrives and we
 should look for a falling edge.
\end_layout

\end_inset

.
 The software measures the time interval between two falling edges using
 the following lines of code.
 To get better results repeat the measurement several times and take average.
 
\end_layout

\begin_layout LyX-Code
import pm
\end_layout

\begin_layout LyX-Code
p = phm.phm()
\end_layout

\begin_layout LyX-Code
print p.f2ftime(0,1)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename ../book2/pics/soundvel-mic.eps
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Velocity of sound by microphone 
\begin_inset LatexCommand label
name "fig:Velocity-of-sound"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here is a table of measurements obtained experimentally:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Distance (cm)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Time (milli seconds)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Speed = distance/time
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.060
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
To be treated as offset
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.350
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
344.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.645
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
341.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.925
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
346.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1.218
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
345.4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1517
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
343.1
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1810
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
342.8
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Study of Pendulum
\end_layout

\begin_layout Standard
Studying the oscillations of a pendulum is part of any elementary physics
 course.
 Since the time period of a pendulum is a function of acceleration due to
 gravity, one can calculate 
\begin_inset Formula $g$
\end_inset

 by doing a pendulum experiment.
 The accuracy of the result depends mainly on how accurate we can measure
 the period 
\begin_inset Formula $T$
\end_inset

 of the pendulum.
 Let us explore the pendulum using phoenix.
\end_layout

\begin_layout Subsection
A Rod Pendulum - measuring acceleration due to gravity
\end_layout

\begin_layout Standard
A rod pendulum is very easy to fabricate.
 We took a cylindrical rod and fixed a knife edge at one end of it to make
 a T shaped structure.
 The pendulum is suspended on the knife edges and its lower end intercepts
 a light barrier while oscillating.
 The light barrier is made of an LED and photo transistor.
 The output of the light barrier is connected to Digital Input D3.
 The program 'rodpend.py' is used for measuring 
\begin_inset Formula $T$
\end_inset

 and calculating the value of 
\begin_inset Formula $g$
\end_inset

.
 The code is listed below.
\end_layout

\begin_layout LyX-Code
import phm, math
\end_layout

\begin_layout LyX-Code
p=phm.phm()
\end_layout

\begin_layout LyX-Code
length = 14.65               # length of the rod pendulum
\end_layout

\begin_layout LyX-Code
pisqr = math.pi * math.pi
\end_layout

\begin_layout LyX-Code
for i in range(50):
\end_layout

\begin_layout LyX-Code
   T = p.pendulum_period(3)/1000000.0
\end_layout

\begin_layout LyX-Code
   g = 4.0 * pisqr * 2.0 * length / (3.0 * T * T)
\end_layout

\begin_layout LyX-Code
   print i, ' ',T, ' ', g
\end_layout

\begin_layout Standard
The output of the program is redirected to a file and a histogram is made
 using 'xmgrace' program as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Measured-'g'.-Histogram"

\end_inset

.
 The mean value and percentage error in the measurement can be obtained
 from the width of the histogram peak.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/rodpend.eps
	width 5cm

\end_inset

 
\begin_inset Graphics
	filename pics/rodpend.jpg
	lyxscale 30
	width 4cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) Histogram of measured values of 
\begin_inset Formula $g$
\end_inset

.
 (b) The experimental setup.
 
\begin_inset LatexCommand label
name "fig:Measured-'g'.-Histogram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nature of oscillations of the pendulum
\end_layout

\begin_layout Standard
A simple pendulum can be studied in several different ways depending on
 the sensor you have got.
 If you have an angle encoder the angular displacement of the pendulum can
 be measured as a function of time.
 What we used is a DC motor with the pendulum attached to its shaft.
 When the pendulum oscillates it rotates the axis of the motor and a small
 time varying voltage is induced across the terminal of the motor.
 This voltage is amplified and plotted as a function of time.
 The experimental setup and output are shown in figure\InsetSpace ~

\begin_inset LatexCommand vref
reference "cap:Pendulum-block-diagram"

\end_inset

.
 The program pend_digitize.py is listed below.
\end_layout

\begin_layout Standard
The output of the program is send to a file and plotted using 
\begin_inset Formula $xmgrace$
\end_inset

.
 The period of oscillation can be extracted by fitting the data with the
 equation of an exponentially decaying sinusoidal wave.
 The equation used for fitting the data is the following.
\end_layout

\begin_layout Standard
\begin_inset Formula $A(t)=A_{\text{0}}\sin(\omega t+\theta)e^{\text{-dt}}+C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $A(t)$
\end_inset

 - Displacement at time t
\end_layout

\begin_layout Itemize
\begin_inset Formula $A_{\text{0}}$
\end_inset

 - Maximum displacement
\end_layout

\begin_layout Itemize
\begin_inset Formula $\omega$
\end_inset

 - Angular velocity
\end_layout

\begin_layout Itemize
\begin_inset Formula $\theta$
\end_inset

 - displacement at t=0
\end_layout

\begin_layout Itemize
d - Damping factor
\end_layout

\begin_layout Itemize
C - Constant to take care of DC offset from amplifiers
\end_layout

\begin_layout Standard
The angular velocity 
\begin_inset Formula $\omega$
\end_inset

is found to be 7.87 and the length of the pendulum is 15.7 cm.
 The calculated value of 'g' using the simple pendulum equation 
\begin_inset Formula $\omega^{\text{2}}L$
\end_inset

 = 972 cm/sec
\begin_inset Formula $^{\text{2}}$
\end_inset

.
 The errors are due to the simple pendulum approaximation and the error
 in measurement of length.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/pendblock.eps
	width 6cm

\end_inset

 
\begin_inset Graphics
	filename pics/digi_pend_xm.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) Experimental setup.
 (b) Angular velocity of the pendulum as a function of time.
 
\begin_inset LatexCommand label
name "cap:Pendulum-block-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/pickup_fit.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Pendulum Data fitted with equation using xmgrace program.
\begin_inset LatexCommand label
name "fig:Pendulum-Data-fitted"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Acceleration due to gravity by time of flight method
\end_layout

\begin_layout Standard

\series medium
The motion of an object falling under gravity is governed by the relation
\series default
 
\begin_inset Formula $s=ut+\frac{1}{2}gt^{2}$
\end_inset


\series medium
 where 
\begin_inset Formula $s$
\end_inset

 is the height from which the object falls, 
\begin_inset Formula $u$
\end_inset

 the initial velocity of the object, 
\begin_inset Formula $g$
\end_inset

 the acceleration due to gravity, and 
\begin_inset Formula $t$
\end_inset

 the time taken.
 So, if we can accurately measure the time taken by an object with a known
 initial velocity, to fall through a known height, the acceleration due
 to gravity can be directly found from this relation.
 If the object is initially at rest, i.e.
 
\begin_inset Formula $u=0$
\end_inset

, the relation reduces to 
\begin_inset Formula $s=\frac{1}{2}gt^{2}$
\end_inset

.
 This experiment is straight forward if we can measure the time of flight
 with the desired accuracy.
 
\end_layout

\begin_layout Subsection
The experimental Setup
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/gravity_setup.jpg
	lyxscale 30
	width 4cm

\end_inset


\begin_inset Graphics
	filename pics/gra1.eps
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) Apparatus used for measuring the time of fall of a mild steel ball.
 (b) Plot of Fall Time Vs height.
\begin_inset LatexCommand label
name "fig:gravity Apparatus"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series medium
The experimental setup used is shown in figure 
\begin_inset LatexCommand ref
reference "fig:gravity Apparatus"

\end_inset

(a).
 
\series default
We drop a spherical object of high density material from a known height
 and measure the time taken by it to fall thru a certain distance.
 High density is required to minimize the effect of air resistance and the
 spherical shape to avoid any dependence on the change in orientation while
 falling.
 The object has to be released under computer control and the arrival time
 of it on the ground also needs to be marked.
 We have used a 
\series medium
mild steel ball of about 2 cm diameter magnetically held by a solenoid,
 taken from a commercially available relay.
 The solenoid is attached to a clamp, which can slide along a metallic meter
 scale mounted vertically.
 The accuracy of height measurement is around one fifth of a millimeter.
 For better accuracy one can use a height gauge with vernier attachment,
 giving an accuracy of 0.02 mm.
 
\end_layout

\begin_layout Standard

\series medium
The solenoid is powered from Digital Output 
\begin_inset Formula $D0$
\end_inset

 , that can be controlled through software.
 When the ball is released from the solenoid it falls on the metal plate
 at the bottom.
 The arrival time can be marked by using a touch sensor or a light barrier.
 We have tried those methods but found it is very easy to use a loudspeaker
 for this purpose.
 The loudspeaker is attached to the base to capture the electrical signal
 generated due to the vibrations created by the impact.
 The loudspeaker output is amplified and connected to one of the Digital
 Input 
\begin_inset Formula $D0$
\end_inset

 of Phoenix.
 The procedure is repeated for different heights and the time intervals
 are measured.
 The Python program used for carrying out the experiment is listed below.
 The last line of the code measures the time interval from clearing Digital
 Output (D0) to attaining a logic HIGH level on Digital Input (D0).
\end_layout

\begin_layout LyX-Code
import phm                      # Load the library
\end_layout

\begin_layout LyX-Code
p = phm.phm()                   # Create Phoenix object
\end_layout

\begin_layout LyX-Code
p.write_outputs(1)              # Power the electro-magnet
\end_layout

\begin_layout LyX-Code
print 'Attach the Iron Ball...' 
\end_layout

\begin_layout LyX-Code
time.sleep(3)                   
\end_layout

\begin_layout LyX-Code
print p.clr2rtime(0,0)          # Measure time
\end_layout

\begin_layout Subsection
Observations and Analysis
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="4">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Height 
\begin_inset Formula $h(cm)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Time 
\begin_inset Formula ${t(s)}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $g=\frac{2h}{t^{2}}$
\end_inset


\begin_inset Formula $(cm/s^{2})$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Formula $g'=\frac{2h}{(t-0.004){}^{2}}$
\end_inset


\begin_inset Formula $(cm/s^{2})^{*}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
93.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.4406
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
959.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
977.1
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
88.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.4285
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
960.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.1
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
83.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.4162
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
959.8
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.5
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
78.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.4037
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
958.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.1
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
73.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3907
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
958.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.1
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
68.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3773
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
957.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
977.8
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
58.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3489
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
955.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
977.3
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
53.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3337
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
954.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
977.5
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3180
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
951.9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
976.3
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
43.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.3013
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
950.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
975.9
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
38.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2831
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
951.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
979.0
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
33.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2643
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
948.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
977.9
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
28.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2438
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
946.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.4
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
23.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.2218
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
940.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
975.2
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
18.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1965
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
939.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
978.5
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
13.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1680
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
930.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
976.4
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
8.13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.1331
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
917.8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
975.6
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Measured values of the Time of flight for different heights.
 The last column shows the value of 
\begin_inset Formula $g$
\end_inset

 calculated after subtracting 4 milliseconds from the the time of flight.
\begin_inset LatexCommand label
name "tab:Height-Vs-Fall"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The fall time is measured for different heights.
 The height is measured from the top of the surface on which the ball falls
 to the bottom of the ball, when it is held by the solenoid.
 The results are shown in table 
\begin_inset LatexCommand ref
reference "tab:Height-Vs-Fall"

\end_inset

.
 
\series medium
The value of 'g' calculated using the expression 
\begin_inset Formula $s=\frac{1}{2}gt^{2}$
\end_inset

 results in lower values of 
\begin_inset Formula $g$
\end_inset

 .
 It happens due to the fact that the measured time of flight is more than
 the actual time of flight since the solenoid does not release the ball
 immediately after switching off the current.
 The correction is more pronounced for lower time of flight because the
 percentage error increases with the reduction in the total value.
 The calculated 
\begin_inset Formula $g$
\end_inset

 shows better agreement with the expected value if a correction of 4 millisecond
s is applied.
 However it is difficult to justify such an arbitrary correction.
 In fact we measured the delay in releasing the ball and found it to be
 around 2 ms.
 The remaining 2 ms seems to be coming from the delay in sensing the time
 of arrival of the ball.
 
\end_layout

\begin_layout Standard

\series medium
The next section describes a better method of analyzing the data, that eliminate
s the systematic errors in a nice way.
 
\end_layout

\begin_layout Subsection
Data analysis by fitting the data 
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/Screenshot.png
	lyxscale 50
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Fall Time Vs Height data is plotted and fitted with the equation 
\begin_inset Formula $a{\scriptscriptstyle 0}+a{\scriptscriptstyle 1}t+a{\scriptscriptstyle 2}t^{2}$
\end_inset

 using the program xmgrace
\begin_inset LatexCommand label
name "fig:Fitting-the-curve"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

In this method, we really don't use the known relationship 
\begin_inset Formula $s=\frac{1}{2}gt^{2}$
\end_inset

 .
 We just express the distance as an arbitrary polynomial function of time
 and extract the coefficients by fitting it with the experimental data.
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
s=a_{0}+a_{1}t+a_{2}t^{2}\label{eq:Time_Dist_poly}\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\series medium
From the definition of acceleration, we know that it is nothing but the
 second derivative of distance with respect to time.
 Differentiating equation 
\begin_inset LatexCommand ref
reference "eq:Time_Dist_poly"

\end_inset

 twice with respect to t, gives
\end_layout

\begin_layout Standard
\begin_inset Formula \[
acceleration=\frac{d^{2}s}{dt^{2}}=2a_{2}\]

\end_inset


\end_layout

\begin_layout Standard

\series medium
The experimental data is shown in table 
\begin_inset LatexCommand ref
reference "tab:Height-Vs-Fall"

\end_inset

 .
 The curve fitting is done using the program
\series default
 
\series medium
\shape italic
xmgrace
\series default
\shape default
 
\series medium
, no correction is applied to the measured values.
 The value of the coefficient 
\begin_inset Formula $a_{2}$
\end_inset

 is 489.57, as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Fitting-the-curve"

\end_inset

, which gives the value of acceleration to be 979.14
\series default
 
\begin_inset Formula $cm/s^{2}$
\end_inset


\series medium
, which is very close to the accepted standard of 981 
\begin_inset Formula $cm/s^{2}$
\end_inset

.

\series default
 
\series medium
The beauty of the method of curve fitting as a tool for analysis, lies in
 the fact that the systematic errors are absorbed by the coefficients 
\begin_inset Formula $a_{0}$
\end_inset

 and 
\begin_inset Formula $a_{1}$
\end_inset

.
 
\end_layout

\begin_layout Section
Study of Timer and Delay circuits using 555 IC
\end_layout

\begin_layout Standard
Constructing astable and monostable multi-vibrators using 
\begin_inset Formula $IC555$
\end_inset

 is done in elementary electronics practicals.
 Using phoenix one can measure the frequency and duty-cycle of the output
 with micro second accuracy.
 In the case of mono-stable Phoenix can apply the trigger pulse and measure
 the width of the output.
\end_layout

\begin_layout Subsection
Timer using 555
\end_layout

\begin_layout Standard
An astable multi-vibrator is wired using IC 555 as shown in figure 
\begin_inset LatexCommand ref
reference "fig:(a)-IC555-circuits"

\end_inset

(a).
 The output of the circuit is fed to CNTR input for frequency measurement
 and then to Digital Input D0 for duty cycle measurement.
 The code used is shown below along with the results obtained at each step.
\end_layout

\begin_layout LyX-Code
print p.measure_frequency()     # signal connected to CNTR
\end_layout

\begin_layout LyX-Code
904
\end_layout

\begin_layout LyX-Code
print p.r2ftime(0,0)            # signal to D0 input
\end_layout

\begin_layout LyX-Code
733
\end_layout

\begin_layout LyX-Code
print p.f2rtime(0,0)
\end_layout

\begin_layout LyX-Code
371
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename pics/osc555.eps
	width 5cm

\end_inset

 
\begin_inset Graphics
	filename pics/mono555.eps
	width 5cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
(a) IC555 oscillator circuit.
 (b) IC555 Monoshot circuit.
 
\begin_inset LatexCommand label
name "fig:(a)-IC555-circuits"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exercise: Cross check the above results with that predicted by the equation
 for frequency and duty cycle.
 The resistor values used are of 1% tolerance and capacitor of 5% tolerance.
\end_layout

\begin_layout Subsection
Mono-stable multi-vibrator 
\end_layout

\begin_layout Standard
The monostable circuit is wired up as shown in figure 
\begin_inset LatexCommand ref
reference "fig:(a)-IC555-circuits"

\end_inset

(b).
 The 555 IC require a LOW TRUE signal at pin 2 to trigger it.
 The output goes HIGH for a duration decided by the R and C values and comes
 back to LOW.
 The following lines of code is used for triggering 555 and measuring the
 time interval from trigger to the falling edge of the signal from pin 3.
 
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(1)
\end_layout

\begin_layout LyX-Code
p.set_pulse_polarity(1)
\end_layout

\begin_layout LyX-Code
p.write_outputs(8)         # keep D3 high
\end_layout

\begin_layout LyX-Code
p.pulse2ftime(3,3)         # pulse on D3 to a falling edge on D3
\end_layout

\begin_layout LyX-Code
123
\end_layout

\begin_layout Standard
Again it is left as an exercise to the reader to verify whether 123 microseconds
 is acceptable based on the RC values used.
\end_layout

\begin_layout Section
Counting Gamma Rays
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/gmcounter.png
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Screeshot of the Geiger-Muller Counter Experiment.
 
\begin_inset LatexCommand label
name "fig:GM Counter"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Gamma rays can be detected using a Geiger-Muller Counter.
 The GM tube is a coaxial tube filled with low pressure gas, with a high
 voltage applied to a thin wire along the axis.
 The passage of radiation causes a momentary discharge that is counted electroni
cally.
 The Phoenix GM counter accessory generates the necessary high voltage and
 counts the pulses produced by radiation.
 The experiment can be done using the GUI shown in figure 
\begin_inset LatexCommand ref
reference "fig:GM Counter"

\end_inset

 or using the simple Python program listed below.
\end_layout

\begin_layout LyX-Code
#Count the GM tune output for one second , ten times.
 
\end_layout

\begin_layout LyX-Code
import phm, time
\end_layout

\begin_layout LyX-Code
p=phm.phm()
\end_layout

\begin_layout LyX-Code
TIME = 1
\end_layout

\begin_layout LyX-Code
print 'Tube voltage = ',p.gm_set_voltage(500)
\end_layout

\begin_layout LyX-Code
for x in range(10):
\end_layout

\begin_layout LyX-Code
     print p.gm_get_count(TIME)
\end_layout

\begin_layout Section
Energy Spectrum of Alpha Particles
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/rad_det_circuit.png
	width 6cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Radiation Detection Circuit block diagram.
\begin_inset LatexCommand label
name "fig:Radiation-Detection-Circuit"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/mca_screenshot.png
	lyxscale 50
	width 10cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Screenshot of the radiation detection program.
 A photograph of the experimental setup is shown on the screen to guide
 the user.
 
\begin_inset LatexCommand label
name "fig:Radiation Detection"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The radiation detection system has been designed as an accessory of the
 Phoenix Interface.
 The focus is on measuring the energy spectrum of the observed radiation.
 An inexpensive PN junction is used for alpha particle detection.
 Gamma radiation can be studied using scintillation or HPGe detectors.
 The required signal processing electronics (Pre-Amplifier, Shaping amplifier,
 discriminator etc.
 as shown in figure 
\begin_inset LatexCommand ref
reference "fig:Radiation-Detection-Circuit"

\end_inset

) has been packaged in to a small box.
 The digitization and the PC interfacing is provided by PHOENIX.
 A screenshot of the GUI program available for this experiment is shown
 in figure 
\begin_inset LatexCommand ref
reference "fig:Radiation Detection"

\end_inset

.
\end_layout

\begin_layout Section
Amplitude Modulation
\end_layout

\begin_layout Standard
Use the program 'Analog Box' from the menu.
 (to be written)
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/am.png
	width 11cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Amplitude modulated waveform.
 Generated using the Analog Box accessory asd captured by Phoenix Analog
 input.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Section
Frequency Modulation
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename pics/fm.png
	width 11cm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Frequency Modulation
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter
Python Library of Phoenix
\begin_inset LatexCommand label
name "cha:Python-Library-of"

\end_inset


\end_layout

\begin_layout Standard
This chapter explains the Python Libray functions for accessing the Phoenix
 hardware.
 They are grouped into sections like Digital I/O, Analog I/O, Time interval
 measurement functions etc.
 The functions belong to a class named 'phm' and will be invoked along with
 the object name.
 Any phoenix program will have the two lines of code shown below, to import
 the library and create an object using one class defined in the library.
\end_layout

\begin_layout LyX-Code
\align block
import phm      # import the phoenix library
\end_layout

\begin_layout LyX-Code
\align block
p = phm.phm()   # object of 'phm' class of 'phm' library
\end_layout

\begin_layout Standard
Phoenix library has online help.
 From the Python interpreter give the command 'help(phm)' after importing
 the 'phm' library.
\end_layout

\begin_layout Section*
Documentation Conventions 
\end_layout

\begin_layout Standard
We define a function by its 
\shape slanted
name, type of data returned by it, its arguments and the data type of all
 the arguments
\shape default
.
 Python functions can have a variable argument list.
 For example a function with two arguments can be called with a single argument
 if the second argument has a default value.
 They can also have named arguments.
 These features are illustrated with the an example function that accepts
 coordinate data in a list variable, and plots it.
\end_layout

\begin_layout Standard
\align left
None = plot(list data, int width=400, int height=300, Widget parent = None)
\end_layout

\begin_layout Itemize
This function returns the Python data type 'None'.
\end_layout

\begin_layout Itemize
The first argument is a list containing the coordinates to be plotted, which
 MUST be provided.
\end_layout

\begin_layout Itemize
The remaining arguments are having default values.
 If the calling program does not specify them, the default value is used.
\end_layout

\begin_layout Itemize
Second and third specify the dimensions of the plot window to be created.
\end_layout

\begin_layout Itemize
The last argument is the name of the parent window, inside which the new
 plot window will be created.
 
\end_layout

\begin_layout Standard
We can invoke this function in many different ways like:
\end_layout

\begin_layout Itemize
plot(data)
\end_layout

\begin_layout Itemize
plot(data,500,300) # width and height are specified in that order
\end_layout

\begin_layout Itemize
plot(data, height = 500) # height only is specified, skipping width
\end_layout

\begin_layout Standard
The following sections will use a format like 
\end_layout

\begin_layout Standard
\align left
return_type = function_name ( type arg1, ..., type argN = value, ...
 )
\end_layout

\begin_layout Standard
If no arguments are required, we will show and empty paranthesis.
 
\shape slanted
The main data types in used are 'int', 'float', and 'list'.

\shape default
 
\shape slanted
None
\shape default
 is the Python data type used if the function returns nothing.
 The convention will be clear from the simple examples in the beginning.
 There are only few functions that accepts variable number of arguments
 or named arguments.
 Most of them have one or two arguments only.
\end_layout

\begin_layout Section
Digital Inputs
\end_layout

\begin_layout Standard
There are four digital input sockets.
 You can connect them externally to Ground or 5 volts 
\begin_inset Foot
status collapsed

\begin_layout Standard
They are TTL inputs.
 Any voltage less than 0.8V is taken as a LOW and greater than 2V is taken
 as a HIGH.
\end_layout

\end_inset

, to make the voltage level HIGH or LOW.
 The software can read the voltage level present on all sockets.
 It can also monitor the level transitions on these sockets with microsecond
 timing resolution, a feature that will be explained later.
\end_layout

\begin_layout Subsection
read_inputs
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code

\emph on
int read_inputs()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The function reurns an integer whose 4 LSBs represents the voltage level
 present at the Digital Input Sockets.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code

\emph on
data = p.read_inputs()
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code

\emph on
print p.read_inputs()
\end_layout

\begin_layout Standard
will print the number 15 ( 1111
\begin_inset Formula $_{bin}$
\end_inset

) if nothing is connected to the sockets, they are all internally pulled
 up to a HIGH.
 Invoking the same function with D0 grounded will return 14.
 
\end_layout

\begin_layout Section
Analog Comparator Input
\end_layout

\begin_layout Standard
The socket marked as CMP behaves in a manner similar to that of Digital
 Inputs.
 In most of the cases it can be considered as the fifth digital input.
 Advanced features of CMP will be discussed later.
\end_layout

\begin_layout Subsection
read_acomp
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code

\emph on
int read_acomp()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The function reurns one if the CMP input is less that 1.23 volts, otherwise
 it returns zero.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code

\emph on
level = p.read_acomp()
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code

\emph on
print p.read_acomp()
\end_layout

\begin_layout Section
Digital Outputs
\end_layout

\begin_layout Standard
There are four digital output sockets.
 You can set the voltage level on them to zero or five volts using software.
 The first Digital Output, D0
\begin_inset Formula $^{*}$
\end_inset

, is transistor buffered and capable of driving up to 100 mA current, it
 should not be used for timing applications.
 All other outputs can provide only up to 5 mA.
 If you connect LEDs to them, use a 1K
\begin_inset Formula $\Omega$
\end_inset

resistor in series with the LED for current limiting.
\end_layout

\begin_layout Subsection
write_outputs
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code

\emph on
None write_outputs(int)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The function takes an integer as argument whose 4 LSBs are used for setting
 the voltage level on the four Digital Output sockets.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code

\emph on
p.write_outputs(15)
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code
\align block

\emph on
p.write_outputs(15)
\emph default
   
\end_layout

\begin_layout LyX-Code
\align block

\emph on
p.write_outputs(8)
\end_layout

\begin_layout Standard
The first line will make all 4 digital outputs HIGH (15 is 1111
\begin_inset Formula $_{binary}$
\end_inset

), the second one will make D3 HIGH and all other LOW.
 Measure the outputs with a voltmeter or by connecting an LED from the sockets
 to ground with a 1K
\begin_inset Formula $\Omega$
\end_inset

resistor in series.
\end_layout

\begin_layout Section
Analog Output
\end_layout

\begin_layout Standard
Phoenix has one Programmable Voltage Source, marked as DAC.
 The voltage level on the DAC socket can be set from 0 to 5V.
 The resolution is only 8 bits, the voltage will change in about 19 mV steps.
 The DAC is implemented by controlling the duty cycle of a 31.25 KHz Pulse
 Width Modulated waveform generated on PWG socket.
 The PWG is internally connected to the DAC socket through a low pass filter.
 Due to this reason, PWG and DAC cannot be used at the same time.
 The quality of the DC output on DAC output can be improved by adding external
 filters.
\end_layout

\begin_layout Subsection
set_voltage
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code

\emph on
None set_voltage(float mV)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Set the output voltage of the DAC.
 The value of 
\shape italic
mV
\shape default
 should be from 0 to 5000.
 It represents voltage in milli volts.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code

\emph on
p.set_voltage(2000)      # Sets 2 volts on DAC socket
\end_layout

\begin_layout Subsection
set_dac
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left

\emph on
None set_dac(int k)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Write a one byte value to the 8 bit DAC.
 The DAC output varies from 0 to 5000 mV.
 Writing a 0 to the DAC results in an output voltage of 0 and writing a
 255 results in an output voltage of 5V.
 Intermediate values give appropriately scaled outputs.
 Almost always, you will not have to use this function in your code - the
 
\emph on
set_voltage
\emph default
 function is much more convenient.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code

\emph on
p.set_dac(127)    # set DAC to nearly 2.5 volts
\end_layout

\begin_layout Section
Analog Inputs
\end_layout

\begin_layout Standard
Phoenix has four channels of analog inputs, CH0, CH1, CH2 and CH3.
 The input voltage MUST be within the 0V to 5V range.
 The input voltage can be digitized with 10 bit resolution, requiring 2
 bytes to store the data.
 It is also possible to ignore the two LSBs and return a 1 byte data.
 
\end_layout

\begin_layout Standard
Phoenix supports two modes of digitizing the analog voltage present at the
 input sockets, 
\shape slanted
single conversion and block mode conversion
\shape default
.
 In the Single conversion mode, the voltage is measured only once and the
 result is returned.
 In the block mode, more than one measurements are done during a single
 function call.
 The calling program can specify the number of measurements to be done and
 the time interval between two consecutive measurements.
 Block reads are necessary for digitizing waveforms.
\end_layout

\begin_layout Subsection
ADC Settings
\end_layout

\begin_layout Subsubsection
select_adc
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None select_adc(int chan)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Selects one from the four channels available.
 The voltage at this analog input will be digitized during the subsequent
 calls to measure the voltage.
 The channel number ranges from 0 to 3.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
select_adc(0)    # selects the first channel
\end_layout

\begin_layout Subsubsection
set_adc_size
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None set_adc_size(int size)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The Phoenix ADC resolution can be set to 8 or 10 bits.
 Calling this function with argument 1 will choose 8 bits, an argument of
 2 chooses 10 bits.
 It is set to 8 bits on powering.
 Programs using ADC must call this function once after a power up.
 
\shape italic
If a program sets the data size to 2 bytes and Phoenix is reset after that,
 a mismatch will occur resulting in communication error since the default
 is 1 byte at the micro-controller side.
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
\align block
p.set_adc_size(1) #set the resolution to 8 bits
\end_layout

\begin_layout LyX-Code
\align block
p.set_adc_size(2) #set it to 10 bits
\end_layout

\begin_layout Subsection
Single Reads
\end_layout

\begin_layout Subsubsection
get_voltage
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
tuple get_voltage()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Reads the analog voltage on the current ADC channel and returns a tuple.
 First element of the tuple is the PC time-stamp and the second element
 is the voltage in milli-volts.
 The timestamp is required for plotting slowly varying parameters as a function
 of time.
 
\end_layout

\begin_layout Standard
This function was earlier called zero_to_5000().
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
res = p.get_voltage()
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout Standard
Connect DAC to CH0 using a piece of wire and run the following program several
 times.
 The result will be fluctuating by around 20 mV.
 Connect a 1K
\begin_inset Formula $\Omega$
\end_inset

 resistor from DAC to CH0 and a 1 uF capacitor from CH0 to GND.
 Run the program again several times to observe the difference.
\begin_inset Foot
status collapsed

\begin_layout Standard
The ripple on the DAC output is reduced by the extra RC filter, resulting
 in a better DC output.
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code
p.set_voltage(3000)
\end_layout

\begin_layout LyX-Code
\align block
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
\align block
p.set_adc_size(2)
\end_layout

\begin_layout LyX-Code
\align block
print p.get_voltage()[1] # print voltage only
\end_layout

\begin_layout Subsubsection
get_voltage_bip
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
tuple get_voltage_bip()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The Phoenix ADC input accepts only voltages within the 0 to 5V range.
 In many experiments the sensors may generate voltages going to negative
 values also.
 The level shifting amplifiers, (-x+5)/2 , convert a -5V to +5V range signal
 into a 0 to 5V signal.
 Calling get_voltage_bip() will return the voltage given to the input of
 the level shifter, so that the user program need not calculate it.
 This function was earlier called minus5000_to_5000().
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
res = p.get_voltage_bip()  # read a bipolar signal
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout Standard
Connect the input of a level shifter to GND, output to CH0 and run the following
 program.
 The third line will print around 2500 mV and the fourth one around zero
 millivolts.
 You may find the values differing by around 10 mV, that is the level of
 accuracy you can get from the ADC used.
 This can be corrected to some extend by calibrating the ADCs using known
 voltages.
\end_layout

\begin_layout LyX-Code
p.set_adc_size(2)
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
print p.get_voltage()[1]
\end_layout

\begin_layout LyX-Code
print p.get_voltage_bip()[1]
\end_layout

\begin_layout Subsubsection
read_adc
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
tuple read_adc()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Digitizes the analog voltage on the current ADC channel (set by the `select_adc'
 call) and returns a number in the range 0-255 or 0-1023 (depending on the
 ADC sample size set by the `set_adc_size' function) and the system time
 stamp as a tuple.
 It is easier to use get_voltage()
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
print p.read_adc()
\end_layout

\begin_layout Subsubsection
adc_input_period
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
int adc_input_period(int chan)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The period of a voltage waveform, in microseconds, on any of the ADC inputs
 can be measured by this function.
 This works fine for square wave inputs with amplitude greater than 1.5 volts.
 The ADC input is internally connected to the Analog Comparator for doing
 this measurement.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
print p.adc_input_period(0)
\end_layout

\begin_layout Subsection
Block Reads
\end_layout

\begin_layout Standard
To capture waveforms having frequency more than several Hertz, we need to
 digitize several hundred points with a single function call.
 The time interval between consecutive digitizations must be kept same.
 The Block Read functions are used for capturing waveforms.
 There are several other supporting functions in this group for setting
 various parameters related to block mode digitization.
\end_layout

\begin_layout Subsubsection
read_block
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
list read_block(int np, int delay, int bipolar = 0)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The first argument is the number of voltage measurements to be done and
 the second is the time interval between them in microseconds.
 The third argument is used for converting the raw data to the voltage value.
 If you are feeding the signal through the level shifters, use 
\series bold
1
\series default
 as the third argument.
 If you do not use the third argument, it is taken as zero by default.
\end_layout

\begin_layout Standard
The channel to digitized and the datasize are set by the select_adc() and
 set_adc_size() functions.
 The maximum number of samples is limited by the size of the buffer inside
 the microcontroller.
 The buffer size is 800 bytes
\begin_inset Foot
status collapsed

\begin_layout Standard
The buffersize for the ATmega32 version of Phoenix is 1800 bytes
\end_layout

\end_inset

, means the maximum is 800 with 8 bit size and 400 with 10 bit size.
 
\end_layout

\begin_layout Standard
The return value is a list containing tuples like 
\shape italic
[(t1,v1), (t2,v2).....]
\shape default
 , where each tuple contains the time and voltage values of one sample.
 In case of any error a single element list containing the error message
 is returned.
 It is the calling programs responsibility to check this before trying to
 use the returned value.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
data = p.read_block(100, 20, 1)
\end_layout

\begin_layout LyX-Code
data = p.read_block(100,20)
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout Standard
Connect PWG to CH0 and run the following program.
\end_layout

\begin_layout LyX-Code
\align block
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
\align block
p.set_adc_size(2)
\end_layout

\begin_layout LyX-Code
p.set_frequency(1000)
\end_layout

\begin_layout LyX-Code
\align block
v = p.read_block(400, 20)
\end_layout

\begin_layout LyX-Code
if len(v) == 1: 
\end_layout

\begin_layout LyX-Code
     print v         #error message
\end_layout

\begin_layout LyX-Code
p.plot(v)
\end_layout

\begin_layout Subsubsection
multi_read_block
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
list multi_read_block(int np, int delay, int bipolar = 0)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
This call is similar to read_block() but capable of digitizing data from
 multiple channels.
 The channels to be digitized are set by 
\shape italic
add_channel() and del_channel()
\shape default
 functions, explained below.
 
\shape italic
The channel selected by select_adc() function has no effect on multi_read_block(
)
\shape default
.
 The arguments have the same meaning as in read_block().
 The size of each item in the returned list is decided by the number of
 active channels.
 Some example results are shown below.
\end_layout

\begin_layout Standard
All channels added : [ [t1, a1, b1, c1, d1], [t2, a2, b2, c2, d2], ....
 ]
\end_layout

\begin_layout Standard
Channels 0 and 1 : [ [t1, a1, b1], [t2, a2, b2], ....
 ]
\end_layout

\begin_layout Standard
Channels 2 and 3 : [ [t1, a1, b1], [t2, a2, b2], ....
 ]
\end_layout

\begin_layout Standard
It should be noted that the returned list does not have information about
 the active channels.
 The calling program should get this from the value of channel mask.
 With all channels selected, the maximum number of samples is 200 with 1
 byte resolution and 100 with 2 byte resolution, decided by the 800 byte
 buffersize.
 In case of any error a single element list containing the error message
 is returned.
 It is the calling programs responsibility to check this before trying to
 use the returned value.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
\align block
v = p.multi_read_block(100, 10)
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code
\align block
p.add_channel(1)
\end_layout

\begin_layout LyX-Code
p.set_adc_size(1)
\end_layout

\begin_layout LyX-Code
\align block
v = p.multi_read_block(5, 10)
\end_layout

\begin_layout LyX-Code
print v
\end_layout

\begin_layout Standard
If you run this code after powering the micro-controller, the result will
 have data from CH0 and CH1, since CH0 is selected by default.
 Each element in the list will have three values, time and two voltages.
 You can explicitly deselect CH0 by calling del_channel(0).
\end_layout

\begin_layout Subsection
Block Read Channel Selection
\end_layout

\begin_layout Standard
The firmware inside Phoenix keeps a 
\shape slanted
4 bit channel mask,
\shape default
 whose bits can be set by add_channel() and cleared by del_channel().
 The channel mask decides which all channels will be read during a multi_read_bl
ock() call.
 For example, if the channel mask is 5 (0101
\begin_inset Formula $_{binary}$
\end_inset

), CH0 and CH2 will be read.
 The function get_chanmask() returns the current values of the channel mask.
 The number of elements in each item of the list returned by multi_read_block()
 depends on the number of currently active channels.
 If all the channels are set, each item will have five elements, where the
 first one is the time value and the remaining four are the voltage levels
 at the four channels.
 
\end_layout

\begin_layout Subsubsection
add_channel , del_channel 
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None add_channel(int chan)
\end_layout

\begin_layout LyX-Code
None del_channel(int chan)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
add_channel() sets the specified bit in the Channel Mask and del_channel()
 clears it.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
\align block
p.add_channel(1)
\end_layout

\begin_layout LyX-Code
\align block
p.del_channel(3)
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code
\align block
for k in range(4):
\end_layout

\begin_layout LyX-Code
\align block
    p.del_channel(k)  # deselect all channels
\end_layout

\begin_layout LyX-Code
p.add_channel(3)      # Add the fourth channel
\end_layout

\begin_layout LyX-Code
\align block
v = p.multi_read_block(100, 10, 0)
\end_layout

\begin_layout LyX-Code
p.plot(v)
\end_layout

\begin_layout Subsubsection
get_chanmask
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int get_chanmask()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
This function returns the value of the current channel mask.
 The four LSBs of the returned integer contains the selected channel information.
 This call is used by programs like CRO to interpret the data returned by
 multi_read_block() function.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
mask = p.get_chanmask()
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code
\align block
print p.get_chanmask()
\end_layout

\begin_layout Subsection
Block Read Modifiers
\end_layout

\begin_layout Standard
The behavior of block reads calls can be controlled in several ways to enhance
 their flexibility.
 They can be made to start only when the input is between some specified
 limits, this feature is essential for getting a stable trace for CRO applicatio
ns.
\end_layout

\begin_layout Standard
You can also synchronize the beginning of digitization process with some
 external event.
 Digitization is made to wait for specified level changes on a digital input.
 This feature is useful for digitizing transient waveforms.
 The synchronizing signal is derived from the waveform itself and applied
 to a digital input.
 
\end_layout

\begin_layout Standard
It is also possible to SET, CLEAR or PULSE one of the digital outputs just
 before starting the digitization process.
 The control functions only changes the settings at the micro-controller
 end, the actions are visible only when a block read call is made.
\end_layout

\begin_layout Subsubsection
set_adc_trig
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None set_adc_trig(float lower, float upper, int shifted = 0)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
A CRO application typically reads a number of samples from the ADC in bulk
 and plots it on to the screen; this process is repeated.
 If every time we start digitizing from a different part of the signal (say
 a periodic sine wave), the display will not remain static and will tend
 to `run around'.
 The solution is to fix the starting point for each scan.
 The set_adc_trig() tells the read block calls to start the action only
 when the input voltage is changing from lower to upper.
 The trigger levels are specified in millivolts.
 The third argument is 1 when the level shifters are used.
 If you omit that argument, zero is taken by default.
 
\shape italic
This function assumes that the ADC is set to 8 bit resolution.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.set_adc_trig(2000, 2200,0)
\end_layout

\begin_layout LyX-Code
p.set_adc_trig(-200, 200, 1)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.set_frequency(500)
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
p.set_adc_size(1)
\end_layout

\begin_layout LyX-Code
# p.set_adc_trig(1000, 4000, 0)
\end_layout

\begin_layout LyX-Code
p.set_adc_trig(0, 200)
\end_layout

\begin_layout LyX-Code
while 1:
\end_layout

\begin_layout LyX-Code
    x = p.read_block(400, 20, 0)
\end_layout

\begin_layout LyX-Code
    p.plot_data(x)
\end_layout

\begin_layout Standard
Connect PWG to CH0 and run this code.
 Run it again after commenting line 3 instead of line 4 and observe the
 change in the stability of the trace.
\end_layout

\begin_layout Subsubsection
enable_wait_high, enable_wait_low
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None enable_wait_high(int digin)
\end_layout

\begin_layout LyX-Code
None enable_wait_low(int digin)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
A block_read or multi_read_block called after invoking this will wait for
 the specified digital input socket to go HIGH / LOW before starting digitizatio
n.
 If that does not happen, a timeout error will happen and the read_block()
 will return a None.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.enable_wait_high(0)
\end_layout

\begin_layout LyX-Code
p.enable_wait_low(0)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.enable_wait_low(0)
\end_layout

\begin_layout LyX-Code
p.enable_wait_high(2)
\end_layout

\begin_layout LyX-Code
x = p.read_block(200,20,0)
\end_layout

\begin_layout Standard
The first call to wait for a LOW on D0 is reset by the second call and the
 read_block waits only for the digital input D2 to go HIGH.
 An example to capture a transient waveform is explained below.
\end_layout

\begin_layout Standard
Connect a loudspeaker between the input of the non-inverting amplifier and
 GND.
 Set the gain resistor to 100 
\begin_inset Formula $\Omega$
\end_inset

.
 Connect the output of the amplifier to CH0 through the level shifter.
 Connect it to Digital Input D0 through a 1K
\begin_inset Formula $\Omega$
\end_inset

 resistor.
 Run the following code and immediately tap the loudspeaker lightly.
\end_layout

\begin_layout LyX-Code
p.enable_wait_high(0)
\end_layout

\begin_layout LyX-Code
p.select_adc(0)
\end_layout

\begin_layout LyX-Code
x = p.read_block(400,20,0)
\end_layout

\begin_layout Standard
The read_block() will wait until D0 goes high.
 The electrical signal from the loudspeaker will make this and the digitization
 will start from that point.
\end_layout

\begin_layout Subsubsection
disable_wait
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None disable_wait()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
This function will cancel the effect of calling enable_wait_low or enable_wait_h
igh.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
disable_wait()
\end_layout

\begin_layout Subsubsection
enable_set_high, enable_set_low
\begin_inset LatexCommand label
name "sub:enable_set_high,-enable_set_low"

\end_inset


\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None enable_set_high(int digout)
\end_layout

\begin_layout Quotation
\align left
None enable_set_low(int digout)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
In some applications, it would be necessary to make a digital output socket
 go high/low before digitization starts.
 It is ofcourse possible to do this by first calling write_outputs and then
 starting digitization - but the in-between delay may not be acceptable
 in some applications.
 This function, when called with a digital output socket number as argument,
 makes a subsequent ADC block digitization function set/clear the socket
 before it begins the digitization process.
 Action can be defined on only one digital output at a time.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.enable_set_high(0)
\end_layout

\begin_layout LyX-Code
p.enable_set_low(1)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
Capturing the voltage across a capacitor while charging / discharging is
 a typical application of this feature.
 Connect a 1uF capacitor between CH0 and GND.
 Connect a 1K
\begin_inset Formula $\Omega$
\end_inset

 resistor from digital output D3 to CH0 and run the following code.
\end_layout

\begin_layout LyX-Code
p.write_outputs(0)
\end_layout

\begin_layout LyX-Code
time.sleep(1)
\end_layout

\begin_layout LyX-Code
p.enable_set_high(3)
\end_layout

\begin_layout LyX-Code
x = p.read_block(200, 20)
\end_layout

\begin_layout LyX-Code
p.plot(x)
\end_layout

\begin_layout LyX-Code
raw_input()    # wait until a key is pressed
\end_layout

\begin_layout Standard
Due to the third line, D3 is taken to HIGH just before digitizing the voltage
 on CH0.
 The voltage at CH0 will follow it to 5V exponentially.
\end_layout

\begin_layout Subsubsection
enable_pulse_high, enable_pulse_low
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None enable_pulse_high(int digout)
\end_layout

\begin_layout Quotation
\align left
None enable_pulse_low(int digout)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
In some applications, it would be useful to send a Pulse on a digital output
 before digitization starts.
 The enable_pulse_high() maks the speficied output HIGH for some duration
 and then makes it LOW.
 The duration is set by the set_pulse_width() function.
 The calling program should make sure that the socket is set to LOW before
 calling read_block, else a HIGH to LOW transition will result instead of
 a pulse.
 The enable_pulse_low() takes the output LOW and then HIGH after some duration.
\end_layout

\begin_layout Standard
Pulse action can be defined on only one digital output at a time.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.enable_pulse_high(0)
\end_layout

\begin_layout LyX-Code
p.enable_pulse_low(1)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
This function can be used to capture a waveform that is triggered by an
 input signal.
 For example, connect the digital output D3 to the input of a IC555 mono-shot
 circuit and connect the 555 output to CH0.
 Set the mono-shot delay to around a millisecond and run the following code.
\end_layout

\begin_layout LyX-Code
p.write_outputs(8)
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(1)
\end_layout

\begin_layout LyX-Code
p.set_pulse_polarity(1) #  LOW TRUE pulse
\end_layout

\begin_layout LyX-Code
p.enable_pulse_low(3)
\end_layout

\begin_layout LyX-Code
x = p.read_block(300, 10)
\end_layout

\begin_layout LyX-Code
p.plot(x)
\end_layout

\begin_layout LyX-Code
raw_input()    # wait until a key is pressed
\end_layout

\begin_layout Subsubsection
disable_set
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None disable_set()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
This function cancels the effect of enable_set and enable_pulse calls mentioned
 above.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.disable_set()
\end_layout

\begin_layout Section
Waveform Generation and Frequency Counter
\end_layout

\begin_layout Standard
Phoenix can generate waveforms and measure the frequency of an input signal
 in several different ways as explained below.
\end_layout

\begin_layout Subsection
Programmable Waveform Generator (PWG)
\end_layout

\begin_layout Standard
The socket marked as 'PWG' can be programmed to generate a square wave.
 The voltage level swings between zero and five volts.
 The frequency can be set to values from 15 Hz to 4 MHz.
 However, all intermediate values are not possible since the frequencies
 are generated by dividing the 8 MHz clock frequency and comparing with
 set point registers.
 
\end_layout

\begin_layout Subsubsection
set_frequency
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code

\emph on
float set_frequency(float freq)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
The function generates a square waveform, having 50% duty cycle, on the
 PWG socket of the Phoenix box whose frequency is `n' Hz.
 The frequency can vary from 15Hz to 4MHz.
 We may not get the exact frequency which we have specified, only something
 close to it.
 The function returns the actual frequency set in Hz.
 Note that waveform generation is done purely in hardware - the Phoenix
 box can perform some other action while the waveform is being generated.
\end_layout

\begin_layout Standard
The DAC unit, explained later, should not be used while PWG is running -
 doing so will result in a 31.25 KHz waveform whose duty cycle proportional
 to the value set to the DAC.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
\align block

\emph on
m = p.set_frequency(1000)
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout LyX-Code
\align block

\emph on
print p.set_frequency(1000)
\emph default
 
\end_layout

\begin_layout LyX-Code
\align block

\emph on
print p.set_frequency(1005) 
\end_layout

\begin_layout Standard
The first line will print '1000.0' but the second line will print '1008.06',
 that is the possible frequency just above the requested one.
\end_layout

\begin_layout Standard
Connect PWG to CH0 and run the following code to capture the waveform.
\end_layout

\begin_layout LyX-Code
\align block

\emph on
p.set_frequency(1000)
\emph default
 
\end_layout

\begin_layout LyX-Code
\align block
x = p.read_block(300,20)
\end_layout

\begin_layout LyX-Code
p.plot(x)
\end_layout

\begin_layout LyX-Code
raw_input()
\end_layout

\begin_layout Subsection
Arbitrary Waveform Generation
\end_layout

\begin_layout Standard
As discussed earlier, the voltage on the DAC socket can be set to any value
 between 0 to 5V.
 Under software control, it is also possible to change this value in a periodic
 manner to generate a waveform.
 The DAC input values required to generate a single cycle of the waveform
 is loaded into the memory of the micro-controller and they are send to
 the DAC one by one.
 Note that the DAC is set by periodically triggered interrupt service routines
 consuming the processor time.
 Resuts of block reads issued during arbitrary waveform generation may not
 be very accurate.
\end_layout

\begin_layout Subsubsection
load_wavetable
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
int load_wavetable(list wavetable)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Loads the wavetable, a list of 100 numbers, to the eeprom memory of the
 micro-controller.
 Returns the number of bytes loaded, less than 100 indicates an error.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.load_wavetable(v)
\end_layout

\begin_layout Standard
EXAMPLE
\end_layout

\begin_layout LyX-Code
v = []
\end_layout

\begin_layout LyX-Code
for k in range(100):
\end_layout

\begin_layout LyX-Code
    v.append(k)
\end_layout

\begin_layout LyX-Code
p.load_wavetable(v)
\end_layout

\begin_layout Subsubsection
start_wave
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
float start_wave(float freq, int external_dac = 0)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Starts the wave generation on the DAC socket or on the external plug-in
 DAC, using the loaded wavetable.
 This function uses the micro-controller interrupts and the maximum frequency
 is limited to around 150 Hz.
 It is more useful in the low frequency range where frequencies less than
 a Hertz need to be generated.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.load_wave(10,0)
\end_layout

\begin_layout Standard
EXAMPLE
\end_layout

\begin_layout LyX-Code
v = []
\end_layout

\begin_layout LyX-Code
for k in range(100):
\end_layout

\begin_layout LyX-Code
    v.append(k)
\end_layout

\begin_layout LyX-Code
p.load_wavetable(v)
\end_layout

\begin_layout LyX-Code
p.start_wave(20,0) # no external DAC used
\end_layout

\begin_layout Subsubsection
pulse_d0d1
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None pulse_d0d1(float freq)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Generates a squarewave on Digital outputs D0 and D1.
 Only low frequencies are possible.
 
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.pulse_d0d1(20)
\end_layout

\begin_layout Subsubsection
stop_wave
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None stop_wave()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Stops the wave generation on the DAC socket and digital outputs.
 Done by disabling the MCU interrupts.
 
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.stop_wave()
\end_layout

\begin_layout Subsection
measure_frequency
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation

\emph on
int measure_frequency()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Measure the frequency of the square waveform at the CNTR input.
 Returns the frequency in Hz.
 The input frequency can be from several Hertz to one MHz.
 Input to CNTR is monitored for one second and the number of pulses are
 counted.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
Connect PWG to CNTR and run the following code
\end_layout

\begin_layout LyX-Code
p.set_frequency(500)
\end_layout

\begin_layout LyX-Code

\emph on
print p.measure_frequency()
\end_layout

\begin_layout Section
Passive Time Interval Measurements
\end_layout

\begin_layout Standard
Digital Inputs and the CMP socket of Phoenix can be used for measuring time
 intervals with microsecond resolution.
 The time between two level transitions can be measured.
 The transitions defining the start and finish could be on the same socket
 or on different socket.
\end_layout

\begin_layout Subsubsection
r2ftime, f2rtime
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int r2ftime(int digin1, int digin2)
\end_layout

\begin_layout LyX-Code
int f2rtime(int digin1, int digin2)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
r2ftime returns delay in microseconds between a rising edge on digin1 and
 falling edge on digin2 - the sockets can be the same.
 socket numbers 0 to 3 indicate digital input sockets D0 to D3 and socket
 number 4 stands for the CMP input.
 f2rtime() measures time from a falling edge to a riding edge.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.r2ftime(0, 1)
\end_layout

\begin_layout Standard
\align left
EXAMPLES
\end_layout

\begin_layout Standard
Connect PWG to digital input D0 and run the following code, should print
 around 500 usecs.
\end_layout

\begin_layout LyX-Code
p.set_frequency(1000) # half period = 500 usecs
\end_layout

\begin_layout LyX-Code
print p.r2ftime(0,0)
\end_layout

\begin_layout Subsubsection
r2rtime, f2ftime
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int r2rtime(int digin1, int digin2)
\end_layout

\begin_layout LyX-Code
int f2ftime(int digin1, int digin2)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
r2rtime returns delay in microseconds between a rising edge on digin1 and
 rising edge on digin2 - the sockets MUST be distinct.
 If you want to measure the time between two rising edges, use multi_r2rtime().
 f2ftime() measures the time between two falling edges.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.r2rtime(0, 1)
\end_layout

\begin_layout Standard
\align left
EXAMPLES
\end_layout

\begin_layout LyX-Code
print p.r2rtime(0, 1)
\end_layout

\begin_layout Subsubsection
multi_r2rtime
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int multi_r2rtime(int digin, int skipcycles)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Measures time interval between two rising edges of a waveform applied to
 a digital input socket (D0 to D3) or CMP socket.
 If `skipcycles' is zero, period of the waveform is returned.
 In general, `skipcycles' number of consecutive rising and falling edges
 are skipped between the two rising edges.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout Quotation
\align left
p.multi_r2rtime(0, 3)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
Connect PWG to digital input D0 and run the following code.
\end_layout

\begin_layout LyX-Code
p.set_frequency(1000)
\end_layout

\begin_layout LyX-Code
a = p.multi_r2rtime(0,9) # time for 10 cycles in usecs
\end_layout

\begin_layout LyX-Code
frequency = 10.0e6/t10 # in Hz
\end_layout

\begin_layout Standard
For a periodic waveform input, the first line returns the time for one cycle
 and the second one returns the time for 10 cycles ( 9 rising edges in between
 skipped).
 This call can be used for frequency measurement.
 The accuracy can be improved by measuring larges number of cycles.
\end_layout

\begin_layout Subsubsection
pendulum_period
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int pendulum_period(int digin)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
This is equivalent to multi_r2r() with one cycle skipped.
 Some software delay is added to get rid of the noise present at the level
 transitions.
\end_layout

\begin_layout Section
Active Time Interval Measurements
\end_layout

\begin_layout Standard
During some experiments, we need to initiate some action and measure the
 time interval to the result of it.
 The actions are initiated by setting, clearing or by sending pulses on
 the Digital Outputs.
 The results will generate voltage transitions on Digital Inputs or on CMP.
\end_layout

\begin_layout Subsubsection
set2rtime, set2ftime, clr2rtime, clr2ftime
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
int set2rtime(digout, digin)
\end_layout

\begin_layout Quotation
\align left
(remaining functions have similar prototypes)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
These functions SET/CLEAR a digital output socket specified by `digout'
 and wait for the digital input (or analog comparator) socket specified
 by `digin' to go HIGH /LOW.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout Quotation
\align left
p.set2rtime(0, 1)
\end_layout

\begin_layout Subsubsection
pulse2rtime, pulse2ftime
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int pulse2rtime(int digout, digin)
\end_layout

\begin_layout LyX-Code
int pulse2rtime(int digout, digin)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Sends out a single pulse on a Digital Output and waits for a rising/falling
 edge on a Digital Input or CMP.
 The duration and the polarity of the pulse is set by set_pulse_width()
 and set_pulse_polarity() functions.
 On powerup the width is 13 microseconds and polarity is positive ( voltage
 goes from 0V to 5V and comes back to 0V).
 The initial level of 'digout' should be set according to the polarity setting.
 If the polarity is LOW TRUE, the level must be set high beforehand and
 it should be set low for HIGH TRUE pulse.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.pulse2rtime(0, 0)
\end_layout

\begin_layout Standard
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(1)
\end_layout

\begin_layout LyX-Code
p.set_pulse_polarity(1)
\end_layout

\begin_layout LyX-Code
print p.pulse2rtime(0, 1)
\end_layout

\begin_layout Subsubsection
set_pulse_width
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None set_pulse_width(int width)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Sets the pulse width, in microseconds, to be used by the pulse2ftime(),
 pulse2rtime() and pulse_out() functions.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.set_pulse_width(10)
\end_layout

\begin_layout Subsubsection
set_pulse_polarity
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None set_pulse_polarity(int pol)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Sets the pulse polarity to be used by the pulse2ftime(), pulse2rtime() and
 pulse_out() functions.
 pol = 0 means a HIGH TRUE pulse and pol=1 means a LOW TRUE pulse.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.set_pulse_polarity(1)
\end_layout

\begin_layout Section
Histogram Generation
\end_layout

\begin_layout Standard
A level change on the CMP socket of Phoenix can trigger an interrupt service
 routine.
 This feature is used by the accessory for Radiation Detection and Analysis.
 When a charged particle or gamma ray photon is incident on the radiation
 detector, it produces a voltage pulse whose amplitude is proportional to
 the energy of incident radiation.
 This pulse is amplified and given to the ADC CH0 input.
 A logical pulse is given to the CMP socket if the voltage level is above
 the noise threshold.
 Every pulse on CMP runs a program to digitize the voltage present at CH0
 and make a 256 channel histogram using that data.
 Each channel is of 2 byte size and can hold upto 65535 counts.
 If any of the channels read this level, the histogramming is automatically
 stopped to avoid overflow.
 
\shape slanted
Read block calls should not be issued while collecting histogram since the
 same buffer area is used for storing the data.
\end_layout

\begin_layout Standard
The histogramming feature is controlled by the functions explained below.
\end_layout

\begin_layout Subsection
start_hist
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None start_hist()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Enable the CMP interrupts to start histogramming.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.start_hist()
\end_layout

\begin_layout Subsection
stop_hist
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None stop_hist()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Disable the CMP interrupts to stop histogramming.
\end_layout

\begin_layout LyX-Code
USAGE
\end_layout

\begin_layout LyX-Code
p.stop_hist()
\end_layout

\begin_layout Subsection
clear_hist
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None clear_hist()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Clear the 512 byte histogram buffer in the micro-controller
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.clear_hist()
\end_layout

\begin_layout Subsection
read_hist
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None read_hist()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Returns the 256 element (2 byte) histogram data.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
v= p.read_hist()
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
To test this feature, connect PWG to CMP using a cable.
 Connect the level shifter output (will be at 2.5 V when the input is not
 connected) to CH0.
 Run the following program and plot it using 'xmgrace hist.dat' .
\end_layout

\begin_layout LyX-Code
import phm, time 
\end_layout

\begin_layout LyX-Code
p=phm.phm()
\end_layout

\begin_layout LyX-Code
p.set_frequency(1000) 
\end_layout

\begin_layout LyX-Code
p.clear_hist()
\end_layout

\begin_layout LyX-Code
p.start_hist()
\end_layout

\begin_layout LyX-Code
time.sleep(1)
\end_layout

\begin_layout LyX-Code
p.stop_hist() 
\end_layout

\begin_layout LyX-Code
v = p.read_hist()
\end_layout

\begin_layout LyX-Code
f = open('hist.dat','w')
\end_layout

\begin_layout LyX-Code
for k in v: 
\end_layout

\begin_layout LyX-Code
    ss = '%d %d
\backslash
n'%(k[0], k[1] )
\end_layout

\begin_layout LyX-Code
    f.write(ss)
\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Section
Serial Periferal Interface (SPI) Modules
\end_layout

\begin_layout Standard
There are several devices like memory chips, high resolution ADCs, DACs
 etc.
 that can be accessed using the SPI protocol.
 The SPI uses three lines (CLOCK, DATA OUT and DATA IN) for commmunication.
 There will be one Chip Select signal also for each SPI slave device connected.
 Phoenix implements a Software based SPI communication, where the Soclets
 CH3, CH2 and CH1 are used as CLOCK, DATA OUT and DATA IN respectively.
 The Digital Output D3 is used as Chip Select of the ADC, D2 for the DAC
 and D1 for Serial EEPROM.
 
\end_layout

\begin_layout Standard
Library functions are available to access the ADC and DAC plug-in modules
 already developed.
 SPI functions are also accessible from Python library so that new circuits
 can be incorporated without changing the code at the micro-controller side.
\end_layout

\begin_layout Subsection
Raw SPI Functions
\end_layout

\begin_layout Standard
These functions are useful for testing new SPI devices.
 Some SPI devices require the SCLK to be HIGH during CS is enabled, they
 are handled by the _bar functions.
\end_layout

\begin_layout Subsubsection
chip_enable , chip_enable_bar
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None chip_enable(int device)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Enable the selected SPI device by pulling the CS pin LOW.
 Values 0, 1, 2 selcts the devices connected to D3, D2 and D1 respectively.
 Some SPI devices require the SCLK to be HIGH while taking CS LOW, we need
 to call chip_enable_bar() for them.
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
chip_enable(1)  # Selects the SPI whose CS is from Socket D2
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
chip_enable_bar(0) # device on D3
\end_layout

\begin_layout Subsubsection
chip_disable
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None chip_disable()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Disable all SPI devices by taking the CS pins ( digital outputs D3, D2 and
 D1) HIGH.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
chip_disable()
\end_layout

\begin_layout Subsubsection
spi_push, spi_push_bar
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None spi_push(int data)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Sends the 8 bit number to the currently selected SPI device.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
spi_push(255)  
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
chip_enable(1) # selcted the DAC on D2
\end_layout

\begin_layout LyX-Code
data = 1000
\end_layout

\begin_layout LyX-Code
spi_push( (data >> 8) & 255) # push high byte
\end_layout

\begin_layout LyX-Code
spi_push(data & 255)         # then low byte
\end_layout

\begin_layout LyX-Code
chip_disable()
\end_layout

\begin_layout Subsubsection
spi_pull, spi_pull_bar
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
int spi_pull()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Reads an 8 bit number from the currently selected SPI device.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
dat = spi_pull()  
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
chip_enable(0) # selcted the ADC on D3
\end_layout

\begin_layout LyX-Code
cmd = 64 + 15
\end_layout

\begin_layout LyX-Code
spi_push(cmd) # push command
\end_layout

\begin_layout LyX-Code
print spi_pull()         # print ADC ID register
\end_layout

\begin_layout LyX-Code
chip_disable()
\end_layout

\begin_layout Subsection
High Resolution ADC / DAC module
\end_layout

\begin_layout Standard
(picture)
\end_layout

\begin_layout Standard
The AD/DA card has an 8 channel 24 bit ADC and a single channel 16 bit DAC.
 The circuit is optically isolated from Phoenix and powered by +/-12V DC
 supply.
 The software is similar to that of the built-in ADC.
 The maximum input voltage range of the ADC is from 0 to 2.5V, with a resolution
 of few microvolts.
 This is suitable for measuring the output of various sensors without any
 amplification.
 The input range can be reduced down to 20 mV to do more accurate measurements.
\end_layout

\begin_layout Subsubsection
hr_set_voltage
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None hr_set_voltage(float mv)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Sets the output of the Serial DAC from 0 to 2500 mV.
 Minimum stepsize is 38.1 microvolts.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
hr_set_voltage(500.23)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout Standard
hr_set_voltage(100.0)
\end_layout

\begin_layout Subsubsection
hr_select_adc
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None hr_select_adc(int chan)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Selects any channel from 0 to 7.
 When differential inputs are given, channel numbers from 8 to 11 are used.
 The selected channel is used for subsequent digitizations.
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
hr_select_adc(0)    # selects the first channel
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
hr_select_adc(8)    # select CH0 and CH1 as differential Input
\end_layout

\begin_layout Subsubsection
hr_get_voltage
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
list hr_get_voltage()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Reads the analog voltage on the current ADC channel and returns a tuple.
 First element of the tuple is the PC time-stamp and the second element
 is the voltage in milli-volts.
 The timestamp is required for plotting slowly varying parameters as a function
 of time.
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
res = p.hr_get_voltage()
\end_layout

\begin_layout Standard
EXAMPLES
\end_layout

\begin_layout Standard
Connect Serial DAC to Serial ADC CH0 using a piece of wire and run the following
 program several times.
 The result will be fluctuate in the microvolts range.
\end_layout

\begin_layout LyX-Code
p.hr_set_voltage(500.0)
\end_layout

\begin_layout LyX-Code
\align block
p.hr_select_adc(0)
\end_layout

\begin_layout LyX-Code
\align block
print p.hr_get_voltage()[1] # print voltage only
\end_layout

\begin_layout Subsubsection
hr_select_range
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None hr_select_range(int ran)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Set the fullscale range for the currently selected channel.
 Range can be set from 0 to 7.
 The minimum setting for range ( ran = 0) is 20 mV and the maximum range
 is 2.56V (ran = 7) .
 The voltage ranges in millivolts are [20, 40, 80, 160, 320, 640, 1280,
 2560].
 By default the range is set to 2.56V.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
hr_select_range(0)    # selects 20 mV total range.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
hr_select_range(7)    # select 2.56V range
\end_layout

\begin_layout Subsubsection
hr_internal_cal
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
list hr_internal_cal(int ran)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Does an internal calibration of the specified channel and returns the OFFSET
 and GAIN coefficients.
 As such there is no need of calibration if the temperature is near 25
\begin_inset Formula $^{0}$
\end_inset

 .
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
print hr_internal_cal(0)    # print OFFSET and GAIN of channel 0
\end_layout

\begin_layout Subsubsection
hr_external_cal
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
list hr_external_cal(int zero_or_fs)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
A system calibration can be performed by connecting the zero and full scale
 voltages externally.
 Connect the external Zero Level and call this function with 'zero_or_fs'
 set to 0.
 Then connect the full scale voltage and call the function with 'zero_or_fs'
 = 1.
 Calibration is done for the current channel.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
hr_external_cal(0)          # Connect Zero Level to the input
\end_layout

\begin_layout LyX-Code
print hr_external_cal(1)    # Connect Full Scale Voltage to the input
\end_layout

\begin_layout Subsection
Serial EEPROM 
\end_layout

\begin_layout Standard
The Serial EEPROM module uses AT25HP512 eeprom with 64 kbytes memory and
 SPI interface.
 This can be used for data recording applications, without the PC.
 The SPI connections are same as explained above.
 The Digital Output D1 is the Chipselect for EEPROM.
 The function calls to read/write the SEEPROM are explained below.
\end_layout

\begin_layout Subsubsection
seeprom_read
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
print read_seeprom(int addr, int nbytes)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Reads data from the Serial EEPROM plugin module.
 The starting address and the number of bytes to be read are specified.
 Maximum number of bytes that can be read in a single call is 256.
 Data is returned in a list.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
v = p.seeprom_read(2000, 256)  
\end_layout

\begin_layout Subsubsection
seeprom_verify
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Standard
list seeprom_verify(int blocknum, list data)
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
This function is for checking the Serial EEPROM plugin memory.
 We are writing data to SEEPROM in 128 byte blocks.
 The first argument is the block number (from 0 to 511 in a 64K chip) and
 the second is a list containing the data.
 The data provided is first loaded in to the internal EEPROM and then copied
 to the SEEPROM plugin.
 Then it is read back and returned.
 If everything is fine the retunred data must be the same as the one written.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
v = p.seeprom_verify(0, x)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
x = range(128) # makes 128 element list
\end_layout

\begin_layout LyX-Code
v = p.seeprom_verify(0, x) 
\end_layout

\begin_layout LyX-Code
print v
\end_layout

\begin_layout Section
Plotting Functions
\end_layout

\begin_layout Standard
Currently Phoenix uses the Tkinter graphics toolkit for doing graphics.
 Tkinter provides the basic drawing routines on its Canvas Widget.
 Phoenix library contains some routines that plots data returned by Phoenix,
 using Tkinter module.
\end_layout

\begin_layout Subsection
plot
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Quotation
\align left
None plot(data, width=400, height=300, parent=None)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Plots the data returned by read_block and multi_read_block.
 Provides grid, window resizing and coordinate measurement facilities, using
 mouse.
 Any previous plot existing on the window will be deleted.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.plot(v) # v is a list returned by read_block
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
v = p.read_block(200, 10, 1)
\end_layout

\begin_layout LyX-Code
p.plot(v)
\end_layout

\begin_layout Subsection
plot_data
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None plot_data(data, width=400, height=300)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Similar to plot() but with limited features.
 Use this inside infinite loops with fast updating, where plot() function
 will not work properly.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.plot_data(v)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
while 1:
\end_layout

\begin_layout LyX-Code
    v = p.read_block(200, 10, 1)
\end_layout

\begin_layout LyX-Code
    p.plot_data(v)
\end_layout

\begin_layout Subsection
window
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Standard
None = window(int width=400, int height=300, Widget parent = None)
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
The plot() function is the simplest way to plot the data returned by block
 read functions.
 However, if you need a finer control over the process, open a window and
 use functions like line(), box() etc.
 The function window() creates a Tkinter window on the screen.
 If no parent window given, a new root window is created and used as the
 parent.
 This window will be used for subsequent calls to draw objects like line,
 box etc.
 If you do not specify the dimensions, default values will be used.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
canvas = p.window()
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.window()
\end_layout

\begin_layout LyX-Code
raw_input() # show it until a key is pressed
\end_layout

\begin_layout Subsection
set_scale
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None = set_scale(float xmin, float ymin, float xmax, float ymax)
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
For plotting graphs, it is convenient to define a global coordinate system
 according to the range of the values to be plotted.
 The set_scale() function defines the upper and lower limits of the X and
 Y coordinates we will be plotting.
 Ones it is set, the conversion from the global coordinate system to the
 screen coordinates will be taken care by the drawing functions.
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.set_scale(0, -5000, 500, 5000)
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.set_scale(0, 100, 0, 5000)
\end_layout

\begin_layout Subsection
line
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Standard
None = line(list xy, color = 'black')
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
The line() function accepts a list of XY coordinates to plot a line using
 it.
 The coordinate input is of the form [(x1,y1), (x2,y2),.....].
 The color is black by default.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
line([(0,0), (100,100)],'red')
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.window(200,200)
\end_layout

\begin_layout LyX-Code
#p.set_scale(0,0,200,200)
\end_layout

\begin_layout LyX-Code
p.line([(0,0),(50,100),(100,100)],'blue')
\end_layout

\begin_layout LyX-Code
p.line([(0,0),(100,100)],'red')
\end_layout

\begin_layout LyX-Code
raw_input() 
\end_layout

\begin_layout Standard
Run the program to see the output.
 Uncomment line 2 and run it again to see the effect of set-scale function.
 The last line is to keep the graph on the screen until a key is pressed.
\end_layout

\begin_layout Subsection
remove_lines
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None = remove_lines()
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
Delete all the lines plotted on the window.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.remove_lines()
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.window(200,200)
\end_layout

\begin_layout LyX-Code
p.set_scale(0,0,200,200)
\end_layout

\begin_layout LyX-Code
p.line([(0,0), (100,100)],'blue')
\end_layout

\begin_layout LyX-Code
raw_input('Press Enter') 
\end_layout

\begin_layout LyX-Code
p.remove_lines()
\end_layout

\begin_layout LyX-Code
raw_input('Press Enter')
\end_layout

\begin_layout Subsection
box
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout Standard
None = box(list xy, color = 'black')
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
The box() function accepts a list having the XY coordinates of bottom-keft
 and top-right corners.
 The coordinate input is of the form [(x1,y1), (x2,y2)].
 
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
box([(0,0), (100,100)],'red')
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
p.window(200,200)
\end_layout

\begin_layout LyX-Code
p.set_scale(0,0,200,200)
\end_layout

\begin_layout LyX-Code
p.box([(0,0), (100,100)],'blue')
\end_layout

\begin_layout LyX-Code
raw_input() 
\end_layout

\begin_layout Subsection
remove_boxes
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None = remove_boxes()
\end_layout

\begin_layout Standard
\align left
DESCRIPTION
\end_layout

\begin_layout Standard
Delete all the boxes plotted on the window.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.remove_boxes()
\end_layout

\begin_layout Section
Disk Writing
\end_layout

\begin_layout Subsection
save_data
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None save_data(data, fn='plot.dat')
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Save the data returned by the ADC block read functions into a file in multi
 column format.
 Default filename is `plot.dat'; this can be overriden.
\end_layout

\begin_layout Standard
\align left
EXAMPLE
\end_layout

\begin_layout LyX-Code
v = p.read_block(200, 10, 1)
\end_layout

\begin_layout LyX-Code
p.save_data(v, 'sine.dat')
\end_layout

\begin_layout Section
Plugin LCD Display
\end_layout

\begin_layout Standard
Phoenix hardware has a front side socket where an alphanumeric LCD display
 can be connected.
 The alphanumeric LCD display is not used normally, it is meant for developing
 and debugging micro-controller program.
 It is also used when stand-alone devices are made using Phoenix.
 However there are some Python functions also to send characters to the
 LCD display from the PC.
\end_layout

\begin_layout Subsubsection
init_LCD_display
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None init_LCD_display()
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Initialize the LCD display by sending the necessary commands to the display
 module.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.init_LCD_display()
\end_layout

\begin_layout Subsubsection
write_LCD
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None write_LCD(char ch)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Writes a single character to the LCD display at the current cursor position.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.write_LCD_('A')
\end_layout

\begin_layout Subsubsection
message_LCD
\end_layout

\begin_layout Standard
PROTOTYPE
\end_layout

\begin_layout LyX-Code
None message_LCD(char message)
\end_layout

\begin_layout Standard
DESCRIPTION
\end_layout

\begin_layout Standard
Initialize the LCD display and writes a character string (up to 16 characters
 in length) to it.
\end_layout

\begin_layout Standard
\align left
USAGE
\end_layout

\begin_layout LyX-Code
p.message_LCD('hello world')
\end_layout

\begin_layout Chapter
Elementary Python 
\end_layout

\begin_layout Section
Python Basics
\end_layout

\begin_layout Standard
The first reaction from most of the readers would be like ``Oh.
 No.
 One more programming language.
 I already had tough time learning the one know now'' .
 Cool down, Python is not harmful as the name sounds.
 A high school student with average intelligence can pick it up within two
 weeks.
 What is there in a programming language anyway.
 It allows you to create variables, like elementary algebra, and allows
 you to manipulate them using arithmetic and logical operators.
 A sequence of such statements makes the program.
 
\end_layout

\begin_layout Standard
Our approach here will be to study the example programs, try to guess the
 output and compare it with the actual output you get after executing it.
 Correct your understanding if they differ.
 To execute the program, enter the programs listed below in to a file ,
 for example one.py , using a text editor and use the command;
\end_layout

\begin_layout LyX-Code
$ python one.py
\end_layout

\begin_layout Standard
Remember that spaces are important, adding extra spaces in the beginning
 will result in a syntax error.
 Indentation is used for marking group of lines under loops, conditionals,
 functions etc.
 Anything on the right side of a # is treated as a comment.
\end_layout

\begin_layout Section
Variables and Data types 
\end_layout

\begin_layout Standard
Python support numeric data types like Integer, float and complex numbers.
 Type of the variable is decided by the value you assign to it, this method
 is called dynamic typing.
 The variables belong to certain types like 'integer', 'float', 'string'
 etc.
 
\end_layout

\begin_layout LyX-Code
a = 4 # integer type 
\end_layout

\begin_layout LyX-Code
b = 1.5 # floating point type
\end_layout

\begin_layout LyX-Code
c = 2 + 3j # imaginary part is folloed by a 'j'
\end_layout

\begin_layout LyX-Code
print a, a * c # guesss the output
\end_layout

\begin_layout Section
Compound Data types
\end_layout

\begin_layout Standard
Types that comprise smaller pieces are called compound data types.
 They can be used as a single item or as individual elements using the bracket
 [] operator.
\end_layout

\begin_layout LyX-Code
a = 'I am a string' # String is a compound data type
\end_layout

\begin_layout LyX-Code
b = [3, 4.5, 'myname'] # this is a list data type
\end_layout

\begin_layout LyX-Code
b = (3, 4.5, 'myname') # but this is a tuple type
\end_layout

\begin_layout LyX-Code
print a, b, a[0], b[2] # remember ! Indexing starts with zero.
\end_layout

\begin_layout Standard
List is a very versatile data type in Python.
 String and Tuple are immutable, ie.
 you cannot change their individual elements afterwards.
 But a list can be modified in many different ways.
\end_layout

\begin_layout LyX-Code
x = (10, 5.4)
\end_layout

\begin_layout LyX-Code
x[1] = 6.7 # Will give an error
\end_layout

\begin_layout LyX-Code
s = 'no change'
\end_layout

\begin_layout LyX-Code
s[1] = 'a' # Will also give error
\end_layout

\begin_layout LyX-Code
x = [10, 5.4]
\end_layout

\begin_layout LyX-Code
x[1] = 6.7
\end_layout

\begin_layout LyX-Code
print x # will print 6.7 as the second element
\end_layout

\begin_layout LyX-Code
x.append(100)
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout LyX-Code
x = range(10) # creates a list
\end_layout

\begin_layout LyX-Code
print x , x[1] # print full list and then the second element
\end_layout

\begin_layout LyX-Code
size = len(x) 
\end_layout

\begin_layout LyX-Code
for k in range(size):
\end_layout

\begin_layout LyX-Code
print k, x[k] # print index and the list element indexed 
\end_layout

\begin_layout LyX-Code
for item in x: # easier way to access list elements in a for loop
\end_layout

\begin_layout LyX-Code
print item
\end_layout

\begin_layout Section
Control Statements ( while , for, in , if , else & elif )
\end_layout

\begin_layout Standard
Programs generally do not execute from first to last line as shown in the
 previous examples.
 Depending upon the values of some variables it may skip some portion of
 the code or execute some portions several times in a loop.
 Looping is done by using keywords while and for .
 Conditional execution is achieved by using keywords if , else and elif
 .
\end_layout

\begin_layout LyX-Code
x = 1 # program to print multiplication table of 4
\end_layout

\begin_layout LyX-Code
while x <= 10 : # colon and indentation are important
\end_layout

\begin_layout LyX-Code
print x * 4
\end_layout

\begin_layout LyX-Code
x = x + 1 # increment value of x by 1
\end_layout

\begin_layout LyX-Code
print 'Done'
\end_layout

\begin_layout LyX-Code
x = 1
\end_layout

\begin_layout LyX-Code
while x < 6 : 
\end_layout

\begin_layout LyX-Code
if x < 3: # conditional execution
\end_layout

\begin_layout LyX-Code
print 'small ', x # one more level of indentation
\end_layout

\begin_layout LyX-Code
x = x + 1 
\end_layout

\begin_layout LyX-Code
x = 1
\end_layout

\begin_layout LyX-Code
while x < 6 : 
\end_layout

\begin_layout LyX-Code
if x < 3: # conditional execution
\end_layout

\begin_layout LyX-Code
print 'small ', x # one more level of indentation
\end_layout

\begin_layout LyX-Code
elif x > 3:
\end_layout

\begin_layout LyX-Code
print 'big ', x
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_layout LyX-Code
print 'equal'
\end_layout

\begin_layout LyX-Code
x = x + 1 
\end_layout

\begin_layout Section
for loops in Python
\end_layout

\begin_layout Standard
The for loop in Python is more flexible than similar constructs in other
 languages and written using for and in keywords.
 It iterates on a compound data type like a list or tuple.
 To implement loops that will be executed a fixed number of times can be
 implemented using the range() function
\end_layout

\begin_layout LyX-Code
a = [12, 3.2, 'hello']
\end_layout

\begin_layout LyX-Code
for x in a:
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout LyX-Code
print range(10)
\end_layout

\begin_layout LyX-Code
for n in range(10): 
\end_layout

\begin_layout LyX-Code
print n
\end_layout

\begin_layout Section
Keyborad Input 
\end_layout

\begin_layout Standard
Python functions to get a numeric value from the keyboard is input().
 There is another function named raw_input() that accepts the input as a
 character string.
 A message can be given as argument to both the functions.
\end_layout

\begin_layout LyX-Code
x = input('Enter a number ')
\end_layout

\begin_layout LyX-Code
print x , type(x) # try this program with different inputs
\end_layout

\begin_layout LyX-Code
x = raw-input('Enter a string ')
\end_layout

\begin_layout LyX-Code
print 2 * x # Is it a bit crazy ! 
\end_layout

\begin_layout Standard
The function raw_input() gets the input as string.
 To input numeric data types with error checking, one should use this function
 and then convert it into numeric type.
\end_layout

\begin_layout LyX-Code
s = raw-input( 'Enter a number ')
\end_layout

\begin_layout LyX-Code
try: # try and except are error handling stuff in Python
\end_layout

\begin_layout LyX-Code
x = float(s) 
\end_layout

\begin_layout LyX-Code
except: 
\end_layout

\begin_layout LyX-Code
print 'Invalid input.
 Assignng zero' 
\end_layout

\begin_layout LyX-Code
x = 0 
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout Section
Formatted Output
\end_layout

\begin_layout Standard
Python supports an output formatting similar to that of the printf function
 in C.
 The format string will contain % operator followed by format specifiers.
 After the format string the values to be printed are given as a tuple,
 as shown in the examples below .
\end_layout

\begin_layout LyX-Code
a = 2.0 /3 
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout LyX-Code
print 'a = %5.3f' %(a) # upto 3 decimal places
\end_layout

\begin_layout LyX-Code
for k in range(1,11): # A formatted multiplication table
\end_layout

\begin_layout LyX-Code
print '5 x %2d = %2d' %(k, k*5)
\end_layout

\begin_layout Standard
Operators
\end_layout

\begin_layout Standard
Some of the important arithmetic and logical operators in Python are listed
 below.
\end_layout

\begin_layout Standard
Symbol
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Standard
=
\end_layout

\begin_layout Standard
Assignment
\end_layout

\begin_layout Standard
a = 5
\end_layout

\begin_layout Standard
+
\end_layout

\begin_layout Standard
Addition
\end_layout

\begin_layout Standard
a = a + 5
\end_layout

\begin_layout Standard
-
\end_layout

\begin_layout Standard
Subtraction
\end_layout

\begin_layout Standard
a = a - 1
\end_layout

\begin_layout Standard
*
\end_layout

\begin_layout Standard
Multiplication
\end_layout

\begin_layout Standard
a = a * 3
\end_layout

\begin_layout Standard
**
\end_layout

\begin_layout Standard
Exponential
\end_layout

\begin_layout Standard
b = a ** 3
\end_layout

\begin_layout Standard
/
\end_layout

\begin_layout Standard
Division (integer or float)
\end_layout

\begin_layout Standard
2 / 4 (zero) , 2.0 / 4 ( 0.5) 
\end_layout

\begin_layout Standard
==
\end_layout

\begin_layout Standard
Equality test
\end_layout

\begin_layout Standard
if x == 5: 
\end_layout

\begin_layout Standard
!=
\end_layout

\begin_layout Standard
Negated equality test
\end_layout

\begin_layout Standard
if x != 5:
\end_layout

\begin_layout Standard
not
\end_layout

\begin_layout Standard
Logical negation
\end_layout

\begin_layout Standard
x = True ; y = not x
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
Logical AND
\end_layout

\begin_layout Standard
c = a and b
\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
Logical OR
\end_layout

\begin_layout Standard
if a or b : print a * b 
\end_layout

\begin_layout Standard
a, b = raw_input( 'Enter two numbers separated by comma ') # like 2,3
\end_layout

\begin_layout Standard
print a == b
\end_layout

\begin_layout Standard
print a / b # Add more below if you like
\end_layout

\begin_layout Section
User defined functions
\end_layout

\begin_layout Standard
Large programs need to be divided into logical subsections.
 Python allows you to define functions using the keyword def .
 Python functions can be a single variable or a list.
\end_layout

\begin_layout LyX-Code
def sum(a,b): # a trivial function
\end_layout

\begin_layout LyX-Code
return a + b
\end_layout

\begin_layout LyX-Code
print sum(3, 4)
\end_layout

\begin_layout LyX-Code
def factorial(n): # a recursive function
\end_layout

\begin_layout LyX-Code
if n == 0: 
\end_layout

\begin_layout LyX-Code
return 1 
\end_layout

\begin_layout LyX-Code
else: 
\end_layout

\begin_layout LyX-Code
return n * factorial(n-1) 
\end_layout

\begin_layout LyX-Code
print factorial(10) 
\end_layout

\begin_layout Section
Python Modules
\end_layout

\begin_layout Standard
One of the major advantages of Python is the large number of function libraries,
 generally called modules, to do tasks like graphics, networking, scientific
 computation etc.
 Modules are loaded by using the keyword import .
 Several ways of using import is explained below.
\end_layout

\begin_layout LyX-Code
import math
\end_layout

\begin_layout LyX-Code
print math.sin(0.5) # module_name.method_name is the syntax
\end_layout

\begin_layout LyX-Code
from math import sin 
\end_layout

\begin_layout LyX-Code
print sin(0.5) # sin is imported as a local method 
\end_layout

\begin_layout LyX-Code
from math import * # import everything from math library
\end_layout

\begin_layout LyX-Code
print sin(0.5)
\end_layout

\begin_layout Standard
In the second method, we need not type the module name every time.
 But there could be trouble if two modules imported has a function with
 same name.
 Try the following example to see that.
\end_layout

\begin_layout LyX-Code
from scipy import *
\end_layout

\begin_layout LyX-Code
x = linspace(0, 5, 10) # make a 10 element array
\end_layout

\begin_layout LyX-Code
print sin(x) # sin function of scipy can handle array arguments
\end_layout

\begin_layout LyX-Code
from math import * # sin function of math will be called now
\end_layout

\begin_layout LyX-Code
print sin(x) # and will fail with the array argument
\end_layout

\begin_layout Section
File Input/Output
\end_layout

\begin_layout Standard
Disk files can be opened using the function named open() that returns a
 file object.
 Files can be opened for reading or writing.
 There are several methods belonging to the file class that can be used
 for reading and writing data.
\end_layout

\begin_layout LyX-Code
f = open('test.dat' , 'w')
\end_layout

\begin_layout LyX-Code
print f # will print description of the object
\end_layout

\begin_layout LyX-Code
f.write ('This is a test file')
\end_layout

\begin_layout LyX-Code
f.close()
\end_layout

\begin_layout Standard
Above program creates a new file named 'test.dat' (any existing file with
 the same name will be removed in that process) and writes a string to it.
 The following program opens this file for reading the data.
\end_layout

\begin_layout LyX-Code
f = open('test.dat' , 'r')
\end_layout

\begin_layout LyX-Code
print f.read()
\end_layout

\begin_layout LyX-Code
f.close()
\end_layout

\begin_layout Standard
Note that the data written/read are character strings.
 read() function can be used to read a fixed number of characters also,
 as shown below.
\end_layout

\begin_layout LyX-Code
f = open('test.dat' , 'r')
\end_layout

\begin_layout LyX-Code
print f.read(7) # get first seven characters
\end_layout

\begin_layout LyX-Code
print f.read() # get the remaining ones
\end_layout

\begin_layout LyX-Code
f.close()
\end_layout

\begin_layout Standard
Now we will examine how to read a text file and convert it into numeric
 type.
 First we will create a file with two columns of numbers.
\end_layout

\begin_layout LyX-Code
f = open('xy.dat' , 'w')
\end_layout

\begin_layout LyX-Code
for k in range(4):
\end_layout

\begin_layout LyX-Code
s = '%3d %3d
\backslash
n' %(k, 2*k)
\end_layout

\begin_layout LyX-Code
f.write(s) 
\end_layout

\begin_layout LyX-Code
f.close()
\end_layout

\begin_layout Standard
The contents of the file will look like this.
\end_layout

\begin_layout Standard
0 0 
\end_layout

\begin_layout Standard
1 2 
\end_layout

\begin_layout Standard
2 4 
\end_layout

\begin_layout Standard
3 6 
\end_layout

\begin_layout Standard
Now we write a program to read this file and print the numbers.
\end_layout

\begin_layout LyX-Code
f = open('xy.dat' , 'r')
\end_layout

\begin_layout LyX-Code
while 1: # infinite loop
\end_layout

\begin_layout LyX-Code
s = f.readline()
\end_layout

\begin_layout LyX-Code
if s == '' : # Empty string means end of file
\end_layout

\begin_layout LyX-Code
break # terminate the loop
\end_layout

\begin_layout LyX-Code
m = s.split() # split the character string
\end_layout

\begin_layout LyX-Code
print m # result is a list with two elements
\end_layout

\begin_layout LyX-Code
sum = int(m[0]) , int(m[1]) # convert strings into intergers 
\end_layout

\begin_layout LyX-Code
print sum
\end_layout

\begin_layout LyX-Code
f.close()
\end_layout

\begin_layout Section
The pickle module
\end_layout

\begin_layout Standard
In the previous section we have seen that the data going to file is always
 treated as character strings.
 To preserve the data type information, we can use the pickle module, as
 shown below.
 
\end_layout

\begin_layout Standard
import pickle
\end_layout

\begin_layout Standard
f = open('test.pck' , 'w')
\end_layout

\begin_layout Standard
pickle.dump(12.3, f) # write a float type
\end_layout

\begin_layout Standard
f.close()
\end_layout

\begin_layout Standard
Now read it back and check the data type.
\end_layout

\begin_layout Standard
import pickle
\end_layout

\begin_layout Standard
f = open('test.pck' , 'r')
\end_layout

\begin_layout Standard
x = pickle.load(f)
\end_layout

\begin_layout Standard
print x , type(x) # check the type of data read
\end_layout

\begin_layout Standard
f.close()
\end_layout

\begin_layout Section
Python in Science and Mathematics
\end_layout

\begin_layout Standard
We will use Python for plotting mathematical functions, solving equations,
 doing numerical computation etc.
 Most of the operations require working with one or two dimensional matrices.
 Functions capable of working directly on arrays and matrices makes the
 code very simple.
 In the beginning we will use the math module, maily to see its limitations,
 and then go to packages like numpy, scipy, matplotlib etc.
\end_layout

\begin_layout Standard
The first example generates xy coordinates to plot a sine wave, plotting
 will be done using some external program.
 Enter the following code to a file named sine.py , using any text editor.
\end_layout

\begin_layout LyX-Code
import math
\end_layout

\begin_layout LyX-Code
x = 0.0
\end_layout

\begin_layout LyX-Code
while x < math.pi * 4: # plot from zero 4 pi
\end_layout

\begin_layout LyX-Code
print x , math.sin(x)
\end_layout

\begin_layout Standard
The output coming to the screen can be redirected to a file as shown below,
 from the command prompt.
 You can plot the data using some program like xmgrace.
\end_layout

\begin_layout LyX-Code
$ python sine.py > sine.dat
\end_layout

\begin_layout LyX-Code
$ xmgrace sine.dat 
\end_layout

\begin_layout Standard
There are two things we do not like in the above program.
 One is to deal with the loops to generate the data and the other is to
 use an extarnal program to plot the data.
 To solve the first problem, we need to use some modules that supports vectorize
d functions.
 We will use the module numpy that supports operation on compound data types
 like arrays and matrices.
 First we will learn howto make arrays (and also matrices) using numpy.
\end_layout

\begin_layout LyX-Code
import numpy
\end_layout

\begin_layout LyX-Code
x = numpy.arange(1.0, 2.0, 0.1) # start, end and step need to be given
\end_layout

\begin_layout LyX-Code
print x , type(x)
\end_layout

\begin_layout LyX-Code
If you want to save some typing, use an alternate form of import as shown
 below.
\end_layout

\begin_layout LyX-Code
import numpy as np
\end_layout

\begin_layout LyX-Code
x = np.arange(1.0, 2.0, 0.1) # start, end and step need to be given
\end_layout

\begin_layout LyX-Code
print x , type(x)
\end_layout

\begin_layout LyX-Code
Now let us examine some more functions that generate arrays.
\end_layout

\begin_layout LyX-Code
import numpy
\end_layout

\begin_layout LyX-Code
x = numpy.ones(5) # make some one dimensional arrays
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout LyX-Code
x = numpy.zeroes(5)
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout LyX-Code
x = numpy.random.rand(5)
\end_layout

\begin_layout LyX-Code
print x
\end_layout

\begin_layout LyX-Code
a = [1,2,3,4,5] # make a list
\end_layout

\begin_layout LyX-Code
x = numpy.array(a) # and convert to a numpy array
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout Standard
We can also make multi-dimensional arrays.
 Remember that a member of a list can be another list.
 The following example shows how to make a two dimensional array.
\end_layout

\begin_layout LyX-Code
import numpy
\end_layout

\begin_layout LyX-Code
a = [ [1,2] , [3,4] ] # make a list of lists
\end_layout

\begin_layout LyX-Code
x = numpy.array(a) # and convert to a numpy array
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout Standard
Dimensions of arrays can be changed using the reshape function as shown
 below.
\end_layout

\begin_layout LyX-Code
import numpy
\end_layout

\begin_layout LyX-Code
a = arange(10)
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout LyX-Code
a = a.reshape(5,2) # 5 rows and 2 columns
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout Standard
We can perform operations like addition, multiplication etc.
 on arrays.
 The operation is performed on each element.
 To understand the behavior of array arithmetic, see the results of the
 following example program.
\end_layout

\begin_layout LyX-Code
import numpy as np # give a shorter name
\end_layout

\begin_layout LyX-Code
a = np.array([ [1,2] , [3,4] ]) # make a numpy array
\end_layout

\begin_layout LyX-Code
print a
\end_layout

\begin_layout LyX-Code
print 5 * a
\end_layout

\begin_layout LyX-Code
print a * a
\end_layout

\begin_layout LyX-Code
print a / a
\end_layout

\begin_layout Standard
You can also do matrix algebra on arrays by using certain functions.
 The same can be done in an easier manner if you define a matrix instread
 of array.
\end_layout

\begin_layout LyX-Code
import numpy as np # give a shorter name
\end_layout

\begin_layout LyX-Code
a = np.array([ [1,2] , [3,4] ]) # make a numpy array
\end_layout

\begin_layout LyX-Code
print dot(a,a)
\end_layout

\begin_layout LyX-Code
ia = np.linalg.inv(a) # linear algebra subpackage of numpy
\end_layout

\begin_layout LyX-Code
print ia , ia * a # should print identity matrix 
\end_layout

\begin_layout LyX-Code
print a.T # print transpose
\end_layout

\begin_layout Standard
Compare the results of array and matrix data types from the example below.
\end_layout

\begin_layout LyX-Code
import numpy as np # give a shorter name
\end_layout

\begin_layout LyX-Code
a = np.array([ [1,2] , [3,4] ]) # make a numpy array
\end_layout

\begin_layout LyX-Code
m = np.mat([ [1,2] , [3,4] ]) # make a numpy array
\end_layout

\begin_layout LyX-Code
print m * m # Matrix multiplication
\end_layout

\begin_layout LyX-Code
print a ** 3 # element wise cube
\end_layout

\begin_layout LyX-Code
print m ** 3 # multiply matrix 3 times
\end_layout

\begin_layout Section
The matplotlib package
\end_layout

\begin_layout Standard
There are several packages available for plotting under Python.
 We will use matplotlib package that produces good quality outputs and is
 also well documented.
 Matplotlib also supports a Matlab like interface.
\end_layout

\begin_layout LyX-Code
import matplotlib.pyplot as p
\end_layout

\begin_layout LyX-Code
import numpy as np 
\end_layout

\begin_layout LyX-Code
x = [1,2,3]
\end_layout

\begin_layout LyX-Code
y = [4,5,3]
\end_layout

\begin_layout LyX-Code
p.plot(x,y)
\end_layout

\begin_layout LyX-Code
p.xlabel('X')
\end_layout

\begin_layout LyX-Code
p.show()
\end_layout

\begin_layout Standard
Another example
\end_layout

\begin_layout LyX-Code
import matplotlib.pyplot as p
\end_layout

\begin_layout LyX-Code
import numpy as np 
\end_layout

\begin_layout LyX-Code
t = np.arange(0.0, 5.0, 0.2)
\end_layout

\begin_layout LyX-Code
p.plot(t, t**2,'x')
\end_layout

\begin_layout LyX-Code
p.plot(t, t**3,'ro')
\end_layout

\begin_layout LyX-Code
p.show()
\end_layout

\begin_layout Standard
The following example shows plotting in multiple windows.
\end_layout

\begin_layout LyX-Code
import matplotlib.pyplot as p
\end_layout

\begin_layout LyX-Code
import numpy as np 
\end_layout

\begin_layout LyX-Code
t = np.arange(0.0, 5.0, 0.2)
\end_layout

\begin_layout LyX-Code
p.figure(1)
\end_layout

\begin_layout LyX-Code
p.subplot(211)
\end_layout

\begin_layout LyX-Code
p.xlabel('x - axis')
\end_layout

\begin_layout LyX-Code
p.plot(t , t**2, 'o')
\end_layout

\begin_layout LyX-Code
p.subplot(212)
\end_layout

\begin_layout LyX-Code
p.plot(t, t**3)
\end_layout

\begin_layout LyX-Code
p.show()
\end_layout

\begin_layout Standard
To learn more about matplotlib refer to the manual.
\end_layout

\begin_layout Section
Plotting mathematical functions
\end_layout

\begin_layout Standard
One of our objectives is to understand different mathematical functions
 by plotting them graphically.
 We will use nump arange, linspace and logspace functions from numpy to
 generate the input dataset and the vectorized functions to calculate the
 functions.
 The results are plotted using the pyplot subpackage from matplotlib.
\end_layout

\begin_layout LyX-Code
import numpy as np 
\end_layout

\begin_layout LyX-Code
import matplotlib.pyplot as p
\end_layout

\begin_layout LyX-Code
x = np.linspace(0, 2 * np.pi, 101) # why not 100 points ?
\end_layout

\begin_layout LyX-Code
y = np.sin(x)
\end_layout

\begin_layout LyX-Code
p.plot(x,y)
\end_layout

\begin_layout LyX-Code
p.show()
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "1"
key "website"

\end_inset

www.iuac.res.in
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "2"
key "python"

\end_inset

http://www.python.org/
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "3"
key "pramode"

\end_inset

http://linuxgazette.net/111/pramode.html
\end_layout

\begin_layout Bibliography
\begin_inset LatexCommand bibitem
label "5"
key "book"

\end_inset

http://www.iuac.res.in/%7Eelab/phoenix/
\newline
docs/phm_book.pdf
\end_layout

\end_body
\end_document
